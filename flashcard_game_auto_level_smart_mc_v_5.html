<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hebrew ↔ English Flashcard Game (Auto‑Level + Smart MC)</title>
  <style>
    :root{
      --bg:#f7f9fc; --panel:#ffffff; --muted:#6b7280; --text:#0f172a; --accent:#2563eb; --danger:#ef4444; --border:#e5e7eb; --ok:#10b981;
    }
    *{box-sizing:border-box}
    body { margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,sans-serif; background: var(--bg); color: var(--text); padding-left:210px; min-height:100vh; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 20px; }
    h1 { font-size: 26px; margin: 8px 0 12px; }
    textarea { width: 100%; min-height: 220px; border: 1px solid var(--border); padding: 12px; border-radius: 12px; background:#fbfdff; }
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .col{flex:1 1 320px}
    label{display:flex;flex-direction:column;gap:6px;font-size:13px;color:var(--muted)}
    select,input[type="number"],input[type="text"]{background:#fbfdff;border:1px solid var(--border);color:var(--text);padding:10px;border-radius:10px}
    .btn { padding: 10px 14px; border: 1px solid transparent; border-radius: 10px; background: var(--accent); color: white; cursor: pointer; font-weight:600 }
    .btn.ghost{ background:transparent; color:#1f2937; border-color: var(--border); }
    .btn.danger { background: var(--danger); }
    .btn.ok { background: var(--ok); }
    .chip{padding:6px 10px;border-radius:999px;background:#eef2ff;border:1px solid #e0e7ff;color:#3730a3;font-size:12px}

    /* Fullscreen game */
    .game-screen { display: none; position: fixed; top:0; right:0; bottom:0; left:210px; background: var(--panel); z-index: 900; box-sizing: border-box; }
    .game-header{position:sticky;top:0;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid var(--border);background:var(--panel)}
    .back-btn { background: transparent; border: 1px solid var(--border); padding:8px 12px; border-radius:10px; cursor: pointer; }
    .scorebar{display:flex;gap:14px;flex-wrap:wrap;align-items:center;color:#111827}
    .game-body{height:calc(100% - 58px);display:flex;align-items:center;justify-content:center;padding:16px}
    .bigcard{display:flex;flex-direction:column;gap:16px;align-items:center;justify-content:center;width:min(1000px,94vw);min-height:min(62vh,520px);border-radius:16px;background:linear-gradient(180deg,#f8fafc,#f1f5f9);border:1px solid var(--border);position:relative;overflow:hidden}
    .prompt{font-size:clamp(26px,5vw,46px);font-weight:800;text-align:center}
    .prompt[dir="rtl"]{font-family:"Segoe UI Historic","Noto Sans Hebrew",Arial,sans-serif}
    .answer{font-size:clamp(18px,3vw,28px);color:var(--muted);text-align:center;min-height:1.6em}
    #userAnswer{width:100%;max-width:560px;font-size:20px;padding:14px;border-radius:12px;border:1px solid var(--border);background:#fff}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}

    /* Millionaire-style grid */
    #mcBar{display:none; width:min(920px,90vw);}
    #mcGrid{display:grid; grid-template-columns: 1fr 1fr; gap:14px; width:100%;}
    .mc-option{padding:14px 16px; border:1px solid var(--border); border-radius:12px; background:#fff; font-weight:700; text-align:left; cursor:pointer}
    .mc-option.correct{background:#ecfdf5; border-color:#a7f3d0}
    .mc-option.wrong{background:#fef2f2; border-color:#fecaca}
    .mc-option:disabled{opacity:.7; cursor:not-allowed}

    /* Flash feedback */
    .flash-green{animation:flashG .5s ease}
    .flash-red{animation:flashR .5s ease}
    @keyframes flashG{0%{box-shadow:0 0 0 100vmax rgba(16,185,129,.18) inset}100%{box-shadow:none}}
    @keyframes flashR{0%{box-shadow:0 0 0 100vmax rgba(239,68,68,.18) inset}100%{box-shadow:none}}

    /* +5 points burst */
    .burst{position:absolute; top:12%; font-size:28px; font-weight:900; color:#065f46; opacity:0; transform:translateY(10px);}
    .burst.show{animation:rise 900ms ease forwards}
    @keyframes rise{0%{opacity:0; transform:translateY(10px)} 20%{opacity:1; transform:translateY(0)} 100%{opacity:0; transform:translateY(-30px)}}

    /* Confetti */
    .confetti-piece{position:absolute; width:8px; height:14px; opacity:0.9; top:-10px; animation:fall 900ms linear forwards}
    @keyframes fall{to{transform:translateY(120% ) rotate(720deg); opacity:0}}

    /* Next button */
    #nextBtn{display:none}

    /* Auth sidebar */
    .auth-sidebar{position:fixed;left:0;top:0;bottom:0;width:210px;background:linear-gradient(180deg,#e0e7ff,#eff6ff);border-right:1px solid var(--border);box-shadow:4px 0 18px rgba(15,23,42,0.05);padding:28px 18px;display:flex;flex-direction:column;gap:18px;z-index:1100}
    .auth-sidebar h2{margin:0;font-size:18px;color:#1f2937}
    .auth-meta{font-size:13px;color:var(--muted);line-height:1.4}
    .auth-sidebar .btn{width:100%}
    .auth-sidebar .btn + .btn{margin-top:8px}
    .auth-greeting{font-weight:700;color:#1f2937}

    .top-actions{position:fixed;top:18px;right:24px;display:flex;gap:10px;align-items:center;z-index:1100}

    /* Modal */
    .modal-backdrop{position:fixed;inset:0;background:rgba(15,23,42,0.35);display:none;align-items:center;justify-content:center;z-index:1300;padding:20px}
    .modal-backdrop.open{display:flex}
    .modal-card{background:var(--panel);border-radius:18px;padding:26px;width:min(420px,96vw);box-shadow:0 24px 48px rgba(15,23,42,0.16);position:relative}
    .modal-card h2{margin:0 0 12px;font-size:22px}
    .modal-card form{display:flex;flex-direction:column;gap:14px}
    .modal-card label{font-size:13px;color:var(--muted)}
    .modal-close{position:absolute;top:14px;right:14px;background:transparent;border:none;font-size:20px;cursor:pointer;color:var(--muted)}
    .switch-auth{font-size:13px;color:var(--muted)}
    .switch-auth button{background:none;border:none;color:var(--accent);font-weight:600;cursor:pointer;padding:0}
    .error-text{color:var(--danger);min-height:18px;font-size:13px}
    .profile-words{max-height:320px;overflow:auto;margin-top:12px;border:1px solid var(--border);border-radius:12px;background:#fff;padding:12px}
    .profile-words ul{margin:0;padding-left:18px}
    .profile-words li{margin-bottom:8px}
    .profile-empty{font-size:14px;color:var(--muted)}

    @media(max-width:900px){
      body{padding-left:0}
      .auth-sidebar{position:static;width:auto;flex-direction:row;align-items:center;justify-content:space-between;padding:18px 20px;border-right:none;border-bottom:1px solid var(--border);box-shadow:none;background:linear-gradient(180deg,#f1f5f9,#e2e8f0)}
      .auth-sidebar .btn{width:auto}
      .auth-sidebar .btn + .btn{margin-top:0}
      .wrap{padding:20px 16px}
      .game-screen{left:0}
      .top-actions{top:auto;bottom:20px;right:20px}
    }
  </style>
</head>
<body>
  <aside class="auth-sidebar">
    <h2>Player Hub</h2>
    <div>
      <div class="auth-greeting" id="authGreeting">Welcome, Guest</div>
      <div class="auth-meta" id="authStatus">Sign in to save your words.</div>
    </div>
    <button class="btn" id="authOpenBtn">Sign in / Sign up</button>
    <button class="btn ghost" id="signOutBtn" style="display:none">Sign out</button>
  </aside>

  <div class="top-actions">
    <button class="btn ghost" id="profileBtn" style="display:none">My Profile</button>
  </div>

  <div class="modal-backdrop" id="authModal" role="dialog" aria-modal="true" aria-labelledby="authModalTitle">
    <div class="modal-card">
      <button class="modal-close" id="authClose" aria-label="Close">×</button>
      <h2 id="authModalTitle">Sign in</h2>
      <p class="auth-meta" id="authModalSubtitle">Access your personal flashcard history.</p>
      <form id="authForm">
        <label>Username
          <input type="text" id="authUsername" autocomplete="username" required />
        </label>
        <label>Password
          <input type="password" id="authPassword" autocomplete="current-password" required />
        </label>
        <div class="error-text" id="authError"></div>
        <button class="btn" type="submit" id="authSubmit">Sign in</button>
      </form>
      <p class="switch-auth"><span id="authSwitchPrompt">Don't have an account?</span> <button type="button" id="authSwitch">Sign up</button></p>
    </div>
  </div>

  <div class="modal-backdrop" id="profileModal" role="dialog" aria-modal="true" aria-labelledby="profileTitle">
    <div class="modal-card" style="max-width:520px">
      <button class="modal-close" id="profileClose" aria-label="Close">×</button>
      <h2 id="profileTitle">My Profile</h2>
      <p class="auth-meta">Signed in as <strong id="profileUsername">—</strong></p>
      <div class="profile-words" id="profileWords">
        <div class="profile-empty">Start a game to collect words you encounter.</div>
      </div>
    </div>
  </div>

  <!-- SETUP -->
  <div class="wrap" id="mainScreen">
    <h1>Hebrew ↔ English Flashcard Game</h1>
    <div class="row">
      <div class="col">
        <label>Word list
          <textarea id="raw" placeholder="Paste pairs like **שלום – hello** or **ללמוד – to study**, one per line."></textarea>
        </label>
      </div>
      <div class="col" style="align-self:flex-start;display:flex;flex-direction:column;gap:10px">
        <label>Mode
          <select id="mode">
            <option value="type">Type answer</option>
            <option value="flash">Flashcards (no typing)</option>
            <option value="mc4">Multiple choice (4 options)</option>
          </select>
        </label>
        <label>Direction
          <select id="direction">
            <option value="he2en">Hebrew → English</option>
            <option value="en2he">English → Hebrew</option>
            <option value="mixed">Mixed</option>
          </select>
        </label>
        <label>Level (auto‑detect)
          <select id="level">
            <option value="auto">Auto</option>
            <option value="beginner">Beginner</option>
            <option value="intermediate">Intermediate</option>
            <option value="advanced">Advanced</option>
          </select>
        </label>
        <div id="levelNote" class="chip">Level: —</div>
        <label>Shuffle
          <select id="shuffle">
            <option value="1">On</option>
            <option value="0">Off</option>
          </select>
        </label>
        <button class="btn" id="startBtn">Start game</button>
      </div>
    </div>
  </div>

  <!-- GAME (FULLSCREEN) -->
  <div class="game-screen" id="gameScreen">
    <div class="game-header">
      <button class="back-btn" id="backBtn" aria-label="Back">← Back</button>
      <div class="scorebar">
        <span>Score: <strong id="score">0</strong>/<span id="total">0</span></span>
        <span>Streak: <strong id="streak">0</strong></span>
        <span>Remaining: <strong id="remaining">0</strong></span>
        <span class="chip" id="dirChip">—</span>
        <span class="chip" id="liveLevel">—</span>
      </div>
      <div style="visibility:hidden">spacer</div>
    </div>
    <div class="game-body">
      <div class="bigcard">
        <div class="prompt" id="prompt">Paste your list and click Start</div>
        <div class="answer" id="answer"></div>
        <input id="userAnswer" type="text" placeholder="Type your answer… Enter" style="display:none">
        <div class="toolbar" id="flashBar" style="display:none">
          <button class="btn ghost" id="revealBtn">Show answer (Space)</button>
          <button class="btn" id="correctBtn" style="display:none">I was right (1)</button>
          <button class="btn danger" id="wrongBtn" style="display:none">I missed (2)</button>
          <button class="btn ghost" id="skipBtn">Skip</button>
        </div>
        <div class="toolbar" id="mcBar" style="display:none; gap:12px; flex-wrap:wrap; max-width:920px">
          <div id="mcGrid">
            <button class="mc-option" id="optA">A</button>
            <button class="mc-option" id="optB">B</button>
            <button class="mc-option" id="optC">C</button>
            <button class="mc-option" id="optD">D</button>
          </div>
          <button class="btn ok" id="nextBtn">Ready for the next word?</button>
        </div>
        <div class="toolbar">
          <span class="chip">Enter = check</span>
          <span class="chip">Space = reveal</span>
          <span class="chip">A/B/C/D or 1–4 = choose</span>
          <span class="chip">1/2 = mark</span>
          <span class="chip">Esc = back</span>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const mainScreen = $('mainScreen');
  const gameScreen = $('gameScreen');
  const backBtn = $('backBtn');
  const rawEl = $('raw');
  const startBtn = $('startBtn');
  const modeSel = $('mode');
  const dirSel = $('direction');
  const shuffleSel = $('shuffle');
  const levelSel = $('level');
  const levelNote = $('levelNote');
  const promptEl = $('prompt');
  const answerEl = $('answer');
  const userAnswer = $('userAnswer');
  const flashBar = $('flashBar');
  const revealBtn = $('revealBtn');
  const correctBtn = $('correctBtn');
  const wrongBtn = $('wrongBtn');
  const skipBtn = $('skipBtn');
  const mcBar = $('mcBar');
  const optA = $('optA');
  const optB = $('optB');
  const optC = $('optC');
  const optD = $('optD');
  const nextBtn = $('nextBtn');
  const scoreEl = $('score');
  const totalEl = $('total');
  const remainingEl = $('remaining');
  const streakEl = $('streak');
  const dirChip = $('dirChip');
  const liveLevel = $('liveLevel');
  const authOpenBtn = $('authOpenBtn');
  const signOutBtn = $('signOutBtn');
  const authGreeting = $('authGreeting');
  const authStatus = $('authStatus');
  const authModal = $('authModal');
  const authForm = $('authForm');
  const authModalTitle = $('authModalTitle');
  const authModalSubtitle = $('authModalSubtitle');
  const authUsername = $('authUsername');
  const authPassword = $('authPassword');
  const authError = $('authError');
  const authSubmit = $('authSubmit');
  const authSwitch = $('authSwitch');
  const authSwitchPrompt = $('authSwitchPrompt');
  const authClose = $('authClose');
  const profileBtn = $('profileBtn');
  const profileModal = $('profileModal');
  const profileClose = $('profileClose');
  const profileUsername = $('profileUsername');
  const profileWords = $('profileWords');
  let audioCtx;

  const USERS_KEY = 'hf_users_v1';
  const CURRENT_USER_KEY = 'hf_current_user';
  const authState = { mode:'signin', user:null };

  function loadUsers(){
    try {
      const raw = localStorage.getItem(USERS_KEY);
      if(!raw) return [];
      const parsed = JSON.parse(raw);
      if(!Array.isArray(parsed)) return [];
      return parsed
        .filter(u=>u && typeof u.username==='string' && typeof u.password==='string')
        .map(u=>({
          username: u.username,
          password: u.password,
          words: Array.isArray(u.words) ? u.words.map(w=>normalizeWordEntry(w)) : []
        }));
    } catch(err){
      console.warn('Could not parse users from storage', err);
      return [];
    }
  }

  function normalizeWordEntry(entry){
    if(!entry || typeof entry !== 'object'){
      return { key:String(entry||'')||Math.random().toString(36).slice(2), he:String(entry||''), en:[String(entry||'')], addedAt:Date.now() };
    }
    const he = typeof entry.he==='string' ? entry.he : '';
    const enList = Array.isArray(entry.en) ? entry.en.filter(Boolean).map(String) : (entry.en ? [String(entry.en)] : []);
    const keyBase = he.trim() + '||' + enList.join('||').toLowerCase();
    return {
      key: entry.key || keyBase,
      he,
      en: enList,
      addedAt: entry.addedAt || Date.now()
    };
  }

  function saveUsers(users){
    localStorage.setItem(USERS_KEY, JSON.stringify(users));
  }

  function setCurrentUser(username){
    if(username){
      localStorage.setItem(CURRENT_USER_KEY, username);
    } else {
      localStorage.removeItem(CURRENT_USER_KEY);
    }
  }

  function refreshAuth(){
    const current = localStorage.getItem(CURRENT_USER_KEY);
    const users = loadUsers();
    if(current){
      const found = users.find(u=>u.username === current);
      if(found){
        authState.user = { ...found, words: Array.isArray(found.words)? found.words.map(normalizeWordEntry) : [] };
      } else {
        authState.user = null;
        setCurrentUser(null);
      }
    } else {
      authState.user = null;
    }
    updateAuthUI();
  }

  function updateAuthUI(){
    if(authState.user){
      const count = Array.isArray(authState.user.words)? authState.user.words.length : 0;
      authGreeting.textContent = 'Welcome, ' + authState.user.username;
      authStatus.textContent = count ? `${count} saved word${count===1?'':'s'}.` : 'No saved words yet—start a game!';
      signOutBtn.style.display = 'block';
      profileBtn.style.display = 'inline-flex';
      authOpenBtn.textContent = 'Switch account';
    } else {
      authGreeting.textContent = 'Welcome, Guest';
      authStatus.textContent = 'Sign in to save your words.';
      signOutBtn.style.display = 'none';
      profileBtn.style.display = 'none';
      authOpenBtn.textContent = 'Sign in / Sign up';
    }
  }

  function setAuthMode(mode){
    authState.mode = mode;
    const isSignup = mode === 'signup';
    authModalTitle.textContent = isSignup ? 'Create account' : 'Sign in';
    authModalSubtitle.textContent = isSignup ? 'Choose a username and password to save your progress.' : 'Enter your credentials to continue.';
    authSubmit.textContent = isSignup ? 'Sign up' : 'Sign in';
    authSwitchPrompt.textContent = isSignup ? 'Already have an account?' : "Don't have an account?";
    authSwitch.textContent = isSignup ? 'Sign in' : 'Sign up';
    authPassword.value = '';
    authError.textContent = '';
  }

  function openModal(modal){ modal.classList.add('open'); }
  function closeModal(modal){ modal.classList.remove('open'); }

  function openAuthModal(mode){
    setAuthMode(mode);
    authError.textContent = '';
    authForm.reset();
    if(authState.user && mode==='signin'){
      authUsername.value = authState.user.username;
    }
    openModal(authModal);
    setTimeout(()=>{ authUsername.focus(); }, 50);
  }

  function hideAuthModal(){
    closeModal(authModal);
    authForm.reset();
    authError.textContent = '';
  }

  function handleAuthSubmit(){
    const username = authUsername.value.trim();
    const password = authPassword.value.trim();
    if(username.length < 3){ authError.textContent = 'Username must be at least 3 characters.'; return; }
    if(password.length < 4){ authError.textContent = 'Password must be at least 4 characters.'; return; }
    const users = loadUsers();
    if(authState.mode === 'signup'){
      const exists = users.find(u=>u.username.toLowerCase() === username.toLowerCase());
      if(exists){ authError.textContent = 'That username is already taken.'; return; }
      const newUser = { username, password, words: [] };
      users.push(newUser);
      saveUsers(users);
      setCurrentUser(username);
      authState.user = { ...newUser };
      updateAuthUI();
      hideAuthModal();
    } else {
      const exists = users.find(u=>u.username === username);
      if(!exists || exists.password !== password){ authError.textContent = 'Invalid username or password.'; return; }
      setCurrentUser(exists.username);
      authState.user = { ...exists, words: Array.isArray(exists.words)? exists.words.map(normalizeWordEntry) : [] };
      updateAuthUI();
      hideAuthModal();
    }
  }

  function renderProfile(){
    profileWords.innerHTML = '';
    if(!authState.user){
      profileUsername.textContent = '—';
      const empty = document.createElement('div');
      empty.className = 'profile-empty';
      empty.textContent = 'Sign in to view your profile.';
      profileWords.appendChild(empty);
      return;
    }
    profileUsername.textContent = authState.user.username;
    const words = Array.isArray(authState.user.words) ? authState.user.words.slice().sort((a,b)=>(a.addedAt||0)-(b.addedAt||0)) : [];
    if(!words.length){
      const empty = document.createElement('div');
      empty.className = 'profile-empty';
      empty.textContent = 'No words saved yet. Play a round to start collecting!';
      profileWords.appendChild(empty);
      return;
    }
    const list = document.createElement('ul');
    words.forEach(word=>{
      const li = document.createElement('li');
      const heSpan = document.createElement('strong');
      heSpan.textContent = word.he || '';
      li.appendChild(heSpan);
      li.appendChild(document.createTextNode(' – '));
      const enSpan = document.createElement('span');
      const enList = Array.isArray(word.en) ? word.en : [word.en];
      enSpan.textContent = enList.filter(Boolean).join(' / ');
      li.appendChild(enSpan);
      list.appendChild(li);
    });
    profileWords.appendChild(list);
  }

  function recordWordForUser(pair){
    if(!authState.user) return;
    const users = loadUsers();
    const idx = users.findIndex(u=>u.username === authState.user.username);
    if(idx === -1) return;
    const canonicalEn = Array.isArray(pair.en) ? pair.en.map(s=>s.trim()).filter(Boolean) : [String(pair.en||'').trim()].filter(Boolean);
    const key = (pair.he||'').trim() + '||' + canonicalEn.join('||').toLowerCase();
    const words = Array.isArray(users[idx].words) ? users[idx].words.map(normalizeWordEntry) : [];
    const already = words.some(w=>w.key === key || (w.he === pair.he && JSON.stringify(Array.isArray(w.en)?w.en:[w.en]) === JSON.stringify(canonicalEn)));
    if(already) return;
    const entry = { key, he: pair.he, en: canonicalEn, addedAt: Date.now() };
    words.push(entry);
    users[idx].words = words;
    saveUsers(users);
    authState.user = { ...users[idx] };
    authState.user.words = words.slice();
    updateAuthUI();
    if(profileModal.classList.contains('open')){ renderProfile(); }
  }

  refreshAuth();

  authOpenBtn.addEventListener('click', ()=>{
    const existingUsers = loadUsers();
    const mode = authState.user ? 'signin' : (existingUsers.length ? 'signin' : 'signup');
    openAuthModal(mode);
  });

  authSwitch.addEventListener('click', ()=>{
    const nextMode = authState.mode === 'signin' ? 'signup' : 'signin';
    setAuthMode(nextMode);
  });

  authClose.addEventListener('click', hideAuthModal);
  authModal.addEventListener('click', (e)=>{ if(e.target === authModal) hideAuthModal(); });
  authForm.addEventListener('submit', (e)=>{ e.preventDefault(); handleAuthSubmit(); });
  signOutBtn.addEventListener('click', ()=>{ setCurrentUser(null); authState.user = null; updateAuthUI(); closeModal(profileModal); });

  profileBtn.addEventListener('click', ()=>{ renderProfile(); openModal(profileModal); });
  profileClose.addEventListener('click', ()=>{ closeModal(profileModal); });
  profileModal.addEventListener('click', (e)=>{ if(e.target === profileModal) closeModal(profileModal); });

  // --- Utils ---
  function looksHebrew(s){ return /[\u0590-\u05FF]/.test(s||''); }
  function stripStars(s){ if(!s) return ''; return s.replace(/\*\*/g,'').trim().replace(/^\*+\s*/, '').replace(/\s*\*+$/, '').trim(); }
  function noNiqqud(s){ return (s||'').normalize('NFKD').replace(/[\u0591-\u05C7]/g,''); }
  function similarity(a,b){
    a = noNiqqud(a||'').toLowerCase(); b = noNiqqud(b||'').toLowerCase();
    if(!a||!b) return 0;
    let score = 0;
    if(a[0]===b[0]) score += 0.3; // same first letter
    const lenDiff = Math.abs(a.length-b.length); score += Math.max(0, 0.4 - 0.05*lenDiff);
    const bigr = (t)=> new Set(Array.from({length:Math.max(0,t.length-1)}, (_,i)=>t.slice(i,i+2)));
    const A = bigr(a), B = bigr(b);
    let inter = 0; A.forEach(x=>{ if(B.has(x)) inter++; });
    const j = A.size? inter / A.size : 0; score += 0.3*j;
    return score; // 0..1
  }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
  function setDir(el, text){ el.setAttribute('dir', looksHebrew(text)?'rtl':'ltr'); }
  function normalize(s){ return (s||'').toString().trim(); }

  // --- Parsing ---
  function parseRaw(text){
    const lines = (text||'').split(/\r?\n/);
    const sep = /\s*[-–—]\s*/; // hyphen / en-/em-dash
    const out = [];
    for(const line of lines){
      if(!line.trim()) continue;
      const parts = stripStars(line).split(sep);
      if(parts.length < 2) continue;
      const left = stripStars(parts.shift().trim());
      const right = stripStars(parts.join(' - ').trim());
      const heFirst = looksHebrew(left) || (!looksHebrew(right));
      const he = heFirst ? left : right;
      const enSide = heFirst ? right : left;
      const enList = enSide.split(',').map(s=>stripStars(s)).filter(Boolean);
      out.push({ he, en: enList.length? enList : [enSide] });
    }
    return out;
  }

  // --- Level detection ---
  function detectLevel(deck){
    if(!deck.length) return 'beginner';
    const n = deck.length;
    const multiHe = deck.filter(p=>/\s/.test(p.he)).length / n; // phrases
    const avgHeLen = deck.reduce((a,p)=>a+noNiqqud(p.he).length,0)/n;
    const infCount = deck.filter(p=>/^ל[\u0590-\u05FF]/.test(p.he)).length; // infinitives
    const avgEnLen = deck.reduce((a,p)=>a+(p.en[0]||'').length,0)/n;
    let score = 0;
    score += multiHe*0.4; // more phrases → harder
    score += Math.min(1, (avgHeLen-4)/6)*0.3; // longer words → harder
    score += Math.min(1, infCount/n)*0.2; // verbs → a bit harder
    score += Math.min(1, (avgEnLen-4)/8)*0.1;
    if(score < 0.35) return 'beginner';
    if(score < 0.65) return 'intermediate';
    return 'advanced';
  }

  // --- Variant generators (offline, heuristic) ---
  const hebrewLookalikeMap = { 'א':'ע', 'ע':'א', 'ה':'ח', 'ח':'כ', 'כ':'ח', 'ג':'ק', 'ת':'ט', 'ס':'ש', 'ש':'ס', 'ב':'ו', 'ו':'ב' };
  function hebrewVariants(word){
    let w = noNiqqud(word).trim();
    const vars = new Set();
    // add/remove ה prefix
    if(!/^ה/.test(w)) vars.add('ה'+w); else vars.add(w.replace(/^ה/,''));
    // swap one similar letter
    for(let i=0;i<w.length;i++){
      const ch = w[i];
      if(hebrewLookalikeMap[ch]){
        vars.add(w.slice(0,i)+hebrewLookalikeMap[ch]+w.slice(i+1));
      }
    }
    // add common preposition prefixes
    ['ב','ל','מ'].forEach(pref=> vars.add(pref+w));
    return Array.from(vars).filter(x=>x!==w);
  }
  function englishVariants(phrase){
    const p = phrase.trim();
    const vars = new Set();
    // add/remove infinitive marker "to"
    if(/^to\s+/i.test(p)) vars.add(p.replace(/^to\s+/i,'')); else vars.add('to '+p);
    // pluralize simple nouns
    p.split(/\s+/).forEach(tok=>{
      if(/^[a-z]{3,}$/i.test(tok)){
        if(/y$/i.test(tok)) vars.add(p.replace(tok, tok.replace(/y$/i,'ies')));
        else if(!/s$/i.test(tok)) vars.add(p.replace(tok, tok+'s'));
      }
    });
    // verb endings
    if(/^[a-z]{3,}$/i.test(p)){
      vars.add(p+'ing'); vars.add(p+'ed');
    }
    return Array.from(vars).filter(x=>x.toLowerCase()!==p.toLowerCase());
  }

  // --- State ---
  const state = { deck:[], queue:[], i:0, score:0, streak:0, dir:'he2en', mode:'type', revealed:false, mc:{choices:[], correctIndex:-1}, level:'beginner', seen:new Set(), currentIdx:null, currentPair:null };

  function buildQueue(){
    state.queue = state.deck.map((_,i)=>i);
    if(shuffleSel.value==='1') shuffle(state.queue);
    state.i=0; state.score=0; state.streak=0; state.revealed=false;
    state.seen = new Set();
    state.currentIdx = null;
    state.currentPair = null;
    totalEl.textContent = state.queue.length;
    remainingEl.textContent = state.queue.length;
  }
  function nextDirection(){ return dirSel.value==='mixed' ? (Math.random()>0.5?'he2en':'en2he') : dirSel.value; }

  function hideAllUI(){
    userAnswer.style.display='none';
    flashBar.style.display='none';
    mcBar.style.display='none';
    revealBtn.style.display='inline-block';
    correctBtn.style.display='none';
    wrongBtn.style.display='none';
    nextBtn.style.display='none';
    [optA,optB,optC,optD].forEach((btn,i)=>{
    btn.onclick = () => {
      if(btn.disabled) return;
      [optA,optB,optC,optD].forEach(b=>b.disabled=true);
      const ok = i===state.mc.correctIndex;
      const correctText = state.mc.choices[state.mc.correctIndex];
      if(ok){ btn.classList.add('correct'); answerEl.textContent = '✓ ' + correctText; }
      else { btn.classList.add('wrong'); answerEl.textContent = '✗ ' + correctText; }
      endRound(ok);
    };
  });
  }

  function showCard(){
    if(state.i >= state.queue.length){
      promptEl.textContent = '🎉 Done!'; answerEl.textContent=''; hideAllUI(); return;
    }
    const idx = state.queue[state.i];
    const pair = state.deck[idx];
    state.currentIdx = idx;
    state.currentPair = pair;
    state.dir = nextDirection();
    const promptText = state.dir==='he2en' ? pair.he : (pair.en[0]||'');
    const answerText = state.dir==='he2en' ? pair.en.join(' / ') : pair.he;

    if(!state.seen.has(idx)){
      state.seen.add(idx);
      recordWordForUser(pair);
    }

    hideAllUI();
    state.revealed = false;
    promptEl.textContent = promptText; setDir(promptEl, promptText);
    answerEl.textContent = '';
    dirChip.textContent = state.dir==='he2en' ? 'Heb → Eng' : 'Eng → Heb';
    liveLevel.textContent = 'Level: ' + state.level.charAt(0).toUpperCase()+state.level.slice(1);

    if(state.mode==='type'){
      userAnswer.value=''; userAnswer.style.display='block'; userAnswer.focus();
      userAnswer.onkeydown = (e)=>{ if(e.key==='Enter'){ checkTyped(answerText); } };
    } else if(state.mode==='flash'){
      flashBar.style.display='flex';
    } else if(state.mode==='mc4'){
      buildMC(answerText, idx);
    }
  }

  function reveal(answerText){
    if(state.revealed) return;
    state.revealed = true;
    answerEl.textContent = answerText;
    revealBtn.style.display='none';
    correctBtn.style.display='inline-block';
    wrongBtn.style.display='inline-block';
  }

  function mark(correct){
    if(correct){ state.score++; state.streak++; }
    else { state.streak=0; const idx = state.queue[state.i]; const againAt = Math.min(state.queue.length, state.i + 3 + Math.floor(Math.random()*3)); state.queue.splice(againAt,0,idx); }
    scoreEl.textContent = state.score; streakEl.textContent = state.streak;
    state.i++; remainingEl.textContent = Math.max(0, state.queue.length - state.i);
    showCard();
  }

  function checkTyped(correct){
    const guess = userAnswer.value.trim();
    const normalizedCorrect = correct.toLowerCase();
    const isCorrect = normalizedCorrect.split('/').map(s=>s.trim()).includes(guess.toLowerCase());
    answerEl.textContent = (isCorrect?'✓ ':'✗ ') + correct.split('/')[0].trim();
    mark(isCorrect);
  }

  // --- MC (smart, level‑aware) ---
  function buildMC(answerText, currentIdx){
    mcBar.style.display='flex';
    const promptIsHeb = state.dir==='he2en';
    const correct = answerText;

    const pool = [];
    for(let i=0;i<state.deck.length;i++){
      if(i===currentIdx) continue;
      const p = state.deck[i];
      const candidate = promptIsHeb ? (Array.isArray(p.en)?p.en[0]:p.en) : p.he;
      pool.push(candidate);
    }

    const gens = promptIsHeb ? englishVariants(correct) : hebrewVariants(correct);

    const distractors = [];
    const used = new Set([normalize(correct).toLowerCase()]);
    function tryAdd(x){ const n=normalize(x).toLowerCase(); if(!n||used.has(n)) return false; distractors.push(x); used.add(n); return true; }

    if(state.level==='beginner'){
      shuffle(pool); for(const x of pool){ if(tryAdd(x) && distractors.length>=3) break; }
    } else if(state.level==='intermediate'){
      const ranked = pool.map(x=>({x, s: similarity(x, correct)})).sort((a,b)=>Math.abs(0.45-b.s)-Math.abs(0.45-a.s));
      for(const r of ranked){ if(tryAdd(r.x) && distractors.length>=2) break; }
      shuffle(gens); for(const g of gens){ if(tryAdd(g) && distractors.length>=3) break; }
      shuffle(pool); for(const x of pool){ if(distractors.length>=3) break; tryAdd(x); }
    } else {
      const close = pool.map(x=>({x, s: similarity(x, correct)})).sort((a,b)=>b.s-a.s);
      for(const r of close){ if(r.s<0.35) break; if(tryAdd(r.x) && distractors.length>=2) break; }
      for(const g of gens){ if(tryAdd(g) && distractors.length>=3) break; }
      for(const r of close){ if(distractors.length>=3) break; tryAdd(r.x); }
    }

    const choices = [correct, ...distractors.slice(0,3)];
    while(choices.length<4){ const filler = pool[Math.floor(Math.random()*Math.max(1,pool.length))] || correct + ' '; if(!used.has(normalize(filler).toLowerCase())){ choices.push(filler); used.add(normalize(filler).toLowerCase()); } if(choices.length>=4) break; }
    shuffle(choices);
    state.mc.choices = choices;
    state.mc.correctIndex = choices.indexOf(correct);

    const labels=['A','B','C','D'];
    [optA,optB,optC,optD].forEach((btn,i)=>{ btn.textContent = labels[i] + ': ' + choices[i]; btn.setAttribute('data-index', i); btn.classList.remove('correct','wrong'); btn.disabled=false; });
  }

  // --- feedback utils ---
  function getCtx(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); return audioCtx; }
  function beep(seq){ const ctx=getCtx(); let t=ctx.currentTime; seq.forEach(([f,ms])=>{ const o=ctx.createOscillator(); const g=ctx.createGain(); o.frequency.value=f; o.type='sine'; o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t+ms/1000); g.gain.setValueAtTime(0.15,t); g.gain.exponentialRampToValueAtTime(0.001, t+ms/1000); t+=ms/1000; }); }
  function playCorrect(){ beep([[880,120],[1175,120],[1568,180]]); }
  function playWrong(){ beep([[220,160],[196,160]]); }
  function flash(ok){ const card=document.querySelector('.bigcard'); card.classList.remove('flash-green','flash-red'); void card.offsetWidth; card.classList.add(ok?'flash-green':'flash-red'); }
  function showBurst(){ let el=document.createElement('div'); el.className='burst'; el.textContent='+5 points!'; document.querySelector('.bigcard').appendChild(el); requestAnimationFrame(()=>{ el.classList.add('show'); }); setTimeout(()=>el.remove(),1000); }
  function confetti(){ const card=document.querySelector('.bigcard'); for(let i=0;i<24;i++){ const s=document.createElement('div'); s.className='confetti-piece'; s.style.left=Math.random()*100+'%'; s.style.background=`hsl(${Math.floor(Math.random()*360)},90%,60%)`; s.style.transform=`translateY(-10px) rotate(${Math.random()*360}deg)`; card.appendChild(s); setTimeout(()=>s.remove(),1000); } }

  function endRound(ok){ if(ok){ playCorrect(); showBurst(); confetti(); flash(true); setTimeout(()=>{ mark(true); }, 650); } else { playWrong(); flash(false); const ci = state.mc.correctIndex; [optA,optB,optC,optD][ci].classList.add('correct'); nextBtn.style.display='inline-block'; nextBtn.onclick=()=>{ nextBtn.style.display='none'; mark(false); } }
  }

  // --- Events ---
  startBtn.addEventListener('click', ()=>{
    const deck = parseRaw(rawEl.value);
    if(deck.length===0){ alert('Please paste lines like: מילה - word'); return; }
    state.mode = modeSel.value;
    const autoLevel = levelSel.value==='auto' ? detectLevel(deck) : levelSel.value;
    state.level = autoLevel; levelNote.textContent = 'Level: ' + autoLevel; liveLevel.textContent = 'Level: ' + autoLevel;
    state.deck = deck; buildQueue();
    mainScreen.style.display='none'; gameScreen.style.display='block';
    showCard();
  });

  backBtn.addEventListener('click', ()=>{
    gameScreen.style.display='none'; mainScreen.style.display='block';
  });

  // Flashbar actions
  revealBtn.addEventListener('click', ()=>{
    const idx = state.queue[state.i];
    const pair = state.deck[idx];
    const answerText = state.dir==='he2en' ? pair.en.join(' / ') : pair.he;
    reveal(answerText);
  });
  correctBtn.addEventListener('click', ()=> mark(true));
  wrongBtn.addEventListener('click', ()=> mark(false));
  skipBtn.addEventListener('click', ()=>{ state.i++; remainingEl.textContent = Math.max(0, state.queue.length - state.i); showCard(); });

  // MC actions
  [optA,optB,optC,optD].forEach((btn,i)=>{
    btn.onclick = () => {
      const ok = i===state.mc.correctIndex;
      const correctText = state.mc.choices[state.mc.correctIndex];
      answerEl.textContent = (ok?'✓ ':'✗ ') + correctText;
      mark(ok);
    };
  });

  // Keys
  document.addEventListener('keydown', (e)=>{
    if(authModal.classList.contains('open')){ if(e.key==='Escape'){ hideAuthModal(); } return; }
    if(profileModal.classList.contains('open')){ if(e.key==='Escape'){ closeModal(profileModal); } return; }
    if(gameScreen.style.display!=='block') return;
    if(e.key==='Escape'){ backBtn.click(); }
    if(state.mode==='flash'){
      if(e.key===' '){ e.preventDefault(); revealBtn.click(); }
      if(e.key==='1'){ e.preventDefault(); correctBtn.click(); }
      if(e.key==='2'){ e.preventDefault(); wrongBtn.click(); }
    }
    if(state.mode==='mc4'){
      const map = { 'a':0, 'b':1, 'c':2, 'd':3, '1':0, '2':1, '3':2, '4':3 };
      const k = e.key.toLowerCase();
      if(Object.prototype.hasOwnProperty.call(map,k)){
        e.preventDefault();
        [optA,optB,optC,optD][map[k]].click();
      }
    }
    if(state.mode==='type' && e.key==='Enter'){ e.preventDefault(); /* handled on input */ }
  });
})();
</script>
</body>
</html>
