<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hebrew ↔ English Flashcard Game (Auto‑Level + Smart MC)</title>
  <style>
    :root{
      --bg:#f7f9fc; --panel:#ffffff; --muted:#6b7280; --text:#0f172a; --accent:#2563eb; --danger:#ef4444; --border:#e5e7eb; --ok:#10b981;
    }
    *{box-sizing:border-box}
    body { margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,sans-serif; background: var(--bg); color: var(--text); padding-left:210px; min-height:100vh; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 20px; }
    h1 { font-size: 26px; margin: 8px 0 12px; }
    textarea { width: 100%; min-height: 220px; border: 1px solid var(--border); padding: 12px; border-radius: 12px; background:#fbfdff; }
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .col{flex:1 1 320px}
    label{display:flex;flex-direction:column;gap:6px;font-size:13px;color:var(--muted)}
    select,input[type="number"],input[type="text"]{background:#fbfdff;border:1px solid var(--border);color:var(--text);padding:10px;border-radius:10px}
    .btn { padding: 10px 14px; border: 1px solid transparent; border-radius: 10px; background: var(--accent); color: white; cursor: pointer; font-weight:600 }
    .btn.ghost{ background:transparent; color:#1f2937; border-color: var(--border); }
    .btn.danger { background: var(--danger); }
    .btn.ok { background: var(--ok); }
    .chip{padding:6px 10px;border-radius:999px;background:#eef2ff;border:1px solid #e0e7ff;color:#3730a3;font-size:12px}

    /* Fullscreen game */
    .game-screen { display: none; position: fixed; top:0; right:0; bottom:0; left:210px; background: var(--panel); z-index: 900; box-sizing: border-box; }
    .game-header{position:sticky;top:0;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid var(--border);background:var(--panel)}
    .back-btn { background: transparent; border: 1px solid var(--border); padding:8px 12px; border-radius:10px; cursor: pointer; }
    .scorebar{display:flex;gap:14px;flex-wrap:wrap;align-items:center;color:#111827}
    .game-body{height:calc(100% - 58px);display:flex;align-items:center;justify-content:center;padding:16px}
    .bigcard{display:flex;flex-direction:column;gap:16px;align-items:center;justify-content:center;width:min(1000px,94vw);min-height:min(62vh,520px);border-radius:16px;background:linear-gradient(180deg,#f8fafc,#f1f5f9);border:1px solid var(--border);position:relative;overflow:hidden}
    .prompt{font-size:clamp(26px,5vw,46px);font-weight:800;text-align:center}
    .prompt[dir="rtl"]{font-family:"Segoe UI Historic","Noto Sans Hebrew",Arial,sans-serif}
    .answer{font-size:clamp(18px,3vw,28px);color:var(--muted);text-align:center;min-height:1.6em}
    #userAnswer{width:100%;max-width:560px;font-size:20px;padding:14px;border-radius:12px;border:1px solid var(--border);background:#fff}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}

    /* Millionaire-style grid */
    #mcBar{display:none; width:min(920px,90vw);}
    #mcGrid{display:grid; grid-template-columns: 1fr 1fr; gap:14px; width:100%;}
    .mc-option{padding:14px 16px; border:1px solid var(--border); border-radius:12px; background:#fff; font-weight:700; text-align:left; cursor:pointer}
    .mc-option.correct{background:#ecfdf5; border-color:#a7f3d0}
    .mc-option.wrong{background:#fef2f2; border-color:#fecaca}
    .mc-option:disabled{opacity:.7; cursor:not-allowed}

    /* Flash feedback */
    .flash-green{animation:flashG .5s ease}
    .flash-red{animation:flashR .5s ease}
    @keyframes flashG{0%{box-shadow:0 0 0 100vmax rgba(16,185,129,.18) inset}100%{box-shadow:none}}
    @keyframes flashR{0%{box-shadow:0 0 0 100vmax rgba(239,68,68,.18) inset}100%{box-shadow:none}}

    /* +5 points burst */
    .burst{position:absolute; top:12%; font-size:28px; font-weight:900; color:#065f46; opacity:0; transform:translateY(10px);}
    .burst.show{animation:rise 900ms ease forwards}
    @keyframes rise{0%{opacity:0; transform:translateY(10px)} 20%{opacity:1; transform:translateY(0)} 100%{opacity:0; transform:translateY(-30px)}}

    /* Confetti */
    .confetti-piece{position:absolute; width:8px; height:14px; opacity:0.9; top:-10px; animation:fall 900ms linear forwards}
    @keyframes fall{to{transform:translateY(120% ) rotate(720deg); opacity:0}}

    /* Next button */
    #nextBtn{display:none}

    /* Auth sidebar */
    .auth-sidebar{position:fixed;left:0;top:0;bottom:0;width:210px;background:linear-gradient(180deg,#e0e7ff,#eff6ff);border-right:1px solid var(--border);box-shadow:4px 0 18px rgba(15,23,42,0.05);padding:28px 18px;display:flex;flex-direction:column;gap:18px;z-index:1100}
    .auth-sidebar h2{margin:0;font-size:18px;color:#1f2937}
    .auth-meta{font-size:13px;color:var(--muted);line-height:1.4}
    .auth-sidebar .btn{width:100%}
    .auth-sidebar .btn + .btn{margin-top:8px}
    .auth-greeting{font-weight:700;color:#1f2937}

    .top-actions{position:fixed;top:18px;right:24px;display:flex;gap:10px;align-items:center;z-index:1100}

    .loading-cover{position:fixed;inset:0;background:rgba(15,23,42,0.45);display:flex;align-items:center;justify-content:center;z-index:1400;padding:24px;backdrop-filter:blur(3px)}
    .loading-cover[hidden]{display:none}
    .loading-card{background:#fff;border-radius:20px;padding:28px 32px;max-width:420px;width:min(92vw,420px);box-shadow:0 24px 60px rgba(15,23,42,0.25);display:flex;flex-direction:column;gap:18px;align-items:center;text-align:center}
    .loading-spinner{width:46px;height:46px;border-radius:50%;border:4px solid rgba(37,99,235,0.25);border-top-color:var(--accent);animation:spin 1s linear infinite}
    .loading-text{font-weight:700;font-size:18px;color:#1f2937;margin:0}
    .loading-hint{font-size:14px;color:var(--muted);margin:0;line-height:1.4}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Modal */
    .modal-backdrop{position:fixed;inset:0;background:rgba(15,23,42,0.35);display:none;align-items:center;justify-content:center;z-index:1300;padding:20px}
    .modal-backdrop.open{display:flex}
    .modal-card{background:var(--panel);border-radius:18px;padding:26px;width:min(420px,96vw);box-shadow:0 24px 48px rgba(15,23,42,0.16);position:relative}
    .modal-card h2{margin:0 0 12px;font-size:22px}
    .modal-card form{display:flex;flex-direction:column;gap:14px}
    .modal-card label{font-size:13px;color:var(--muted)}
    .modal-close{position:absolute;top:14px;right:14px;background:transparent;border:none;font-size:20px;cursor:pointer;color:var(--muted)}
    .switch-auth{font-size:13px;color:var(--muted)}
    .switch-auth button{background:none;border:none;color:var(--accent);font-weight:600;cursor:pointer;padding:0}
    .error-text{color:var(--danger);min-height:18px;font-size:13px}
    .difficulty-card{max-width:440px;width:min(94vw,440px);text-align:left;display:flex;flex-direction:column;gap:16px}
    .difficulty-options{display:flex;flex-direction:column;gap:12px;margin:4px 0 0}
    .difficulty-option{display:flex;flex-direction:column;align-items:flex-start;gap:4px;padding:14px 16px;border-radius:14px;border:1px solid var(--border);background:#f8fafc;color:var(--text);font-weight:600;font-size:15px;cursor:pointer;transition:all .2s ease}
    .difficulty-option:hover,.difficulty-option:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(37,99,235,0.12);outline:none}
    .difficulty-option:active{transform:translateY(1px)}
    .difficulty-label{font-size:16px;font-weight:700}
    .difficulty-note{font-size:13px;font-weight:500;color:var(--muted)}
    .difficulty-hint{font-size:13px;color:var(--muted);margin:0}
    .profile-words{margin-top:12px;}
    .profile-shell{display:flex;flex-direction:column;gap:12px}
    .profile-empty{font-size:14px;color:var(--muted);border:1px dashed var(--border);border-radius:12px;padding:24px;background:#f8fafc;text-align:center}
    .profile-toolbar{display:flex;flex-wrap:wrap;justify-content:space-between;gap:12px;align-items:flex-start}
    .profile-filter{position:relative}
    .profile-filter .btn{font-size:13px;padding:8px 12px}
    .profile-toolbar-actions{display:flex;gap:8px;flex-wrap:wrap}
    .profile-toolbar-actions .btn{font-size:13px;padding:8px 12px}
    .profile-date-menu{display:none;position:absolute;z-index:20;top:calc(100% + 6px);left:0;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 18px 32px rgba(15,23,42,0.16);padding:12px;min-width:220px;max-height:240px;overflow:auto}
    .profile-date-menu.open{display:block}
    .profile-date-menu ul{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:8px}
    .profile-date-menu li{display:flex;align-items:center;justify-content:space-between;gap:8px;font-size:13px;color:var(--text)}
    .profile-date-menu label{display:flex;align-items:center;gap:8px;cursor:pointer}
    .profile-date-menu small{color:var(--muted);font-size:12px;margin-left:auto}
    .profile-date-menu button{font-size:12px;padding:4px 6px;border-radius:8px;background:transparent;border:1px solid var(--border);cursor:pointer;color:var(--accent);white-space:nowrap}
    .profile-date-menu button:hover{background:rgba(37,99,235,0.08)}
    .profile-table-wrap{border:1px solid var(--border);border-radius:12px;overflow:auto;background:#fff;max-height:320px}
    .profile-table{width:100%;border-collapse:collapse;min-width:100%}
    .profile-table th,.profile-table td{padding:10px 12px;font-size:13px;text-align:left;border-bottom:1px solid var(--border)}
    .profile-table tbody tr:hover{background:#f8fafc}
    .profile-table tbody tr:last-child td{border-bottom:none}
    .profile-table td:first-child,.profile-table th:first-child{text-align:center}
    .profile-footer{display:flex;flex-wrap:wrap;justify-content:space-between;align-items:center;gap:12px}
    .profile-table .guess-count{font-weight:700}
    .profile-table .guess-correct{color:var(--ok)}
    .profile-table .guess-incorrect{color:var(--danger)}
    .profile-selected-count{font-size:13px;color:var(--muted)}

    .profile-modal{width:min(95vw,1100px);max-height:min(92vh,820px);display:flex;flex-direction:column;overflow:hidden}
    .profile-modal .profile-words{flex:1;display:flex;flex-direction:column;gap:16px;min-height:0;overflow:hidden}
    .profile-modal .profile-shell{flex:1;gap:16px;overflow:hidden}
    .profile-modal .profile-shell > *{min-height:0}
    .profile-modal .profile-toolbar{align-items:center}
    .profile-modal .profile-table-wrap{flex:1;max-height:none;min-height:260px}
    .profile-modal .profile-footer{padding-top:4px}
    .profile-modal .profile-empty{min-height:200px;display:flex;align-items:center;justify-content:center}

    @media(max-width:900px){
      body{padding-left:0}
      .auth-sidebar{position:static;width:auto;flex-direction:row;align-items:center;justify-content:space-between;padding:18px 20px;border-right:none;border-bottom:1px solid var(--border);box-shadow:none;background:linear-gradient(180deg,#f1f5f9,#e2e8f0)}
      .auth-sidebar .btn{width:auto}
      .auth-sidebar .btn + .btn{margin-top:0}
      .wrap{padding:20px 16px}
      .game-screen{left:0}
      .top-actions{top:auto;bottom:20px;right:20px}
    }
  </style>
</head>
<body>
  <div class="loading-cover" id="loadingCover" hidden>
    <div class="loading-card" role="status" aria-live="polite">
      <div class="loading-spinner" aria-hidden="true"></div>
      <p class="loading-text" id="loadingText">Collecting connected words…</p>
      <p class="loading-hint" id="loadingHint">Checking trusted language APIs for realistic distractors.</p>
    </div>
  </div>
  <aside class="auth-sidebar">
    <h2>Player Hub</h2>
    <div>
      <div class="auth-greeting" id="authGreeting">Welcome, Guest</div>
      <div class="auth-meta" id="authStatus">Sign in to save your words.</div>
    </div>
    <button class="btn" id="authOpenBtn">Sign in / Sign up</button>
    <button class="btn ghost" id="signOutBtn" style="display:none">Sign out</button>
  </aside>

  <div class="top-actions">
    <button class="btn ghost" id="profileBtn" style="display:none">My Profile</button>
  </div>

  <div class="modal-backdrop" id="authModal" role="dialog" aria-modal="true" aria-labelledby="authModalTitle">
    <div class="modal-card">
      <button class="modal-close" id="authClose" aria-label="Close">×</button>
      <h2 id="authModalTitle">Sign in</h2>
      <p class="auth-meta" id="authModalSubtitle">Access your personal flashcard history.</p>
      <form id="authForm">
        <label>Username
          <input type="text" id="authUsername" autocomplete="username" required />
        </label>
        <label>Password
          <input type="password" id="authPassword" autocomplete="current-password" required />
        </label>
        <div class="error-text" id="authError"></div>
        <button class="btn" type="submit" id="authSubmit">Sign in</button>
      </form>
      <p class="switch-auth"><span id="authSwitchPrompt">Don't have an account?</span> <button type="button" id="authSwitch">Sign up</button></p>
    </div>
  </div>

  <div class="modal-backdrop" id="profileModal" role="dialog" aria-modal="true" aria-labelledby="profileTitle">
    <div class="modal-card profile-modal">
      <button class="modal-close" id="profileClose" aria-label="Close">×</button>
      <h2 id="profileTitle">My Profile</h2>
      <p class="auth-meta">Signed in as <strong id="profileUsername">—</strong></p>
      <div class="profile-words" id="profileWords">
        <div class="profile-empty" id="profileEmpty">Start a game to collect words you encounter.</div>
        <div class="profile-shell" id="profileShell" hidden>
          <div class="profile-toolbar">
            <div class="profile-filter">
              <button class="btn ghost profile-date-toggle" id="profileDateToggle" type="button" aria-haspopup="listbox" aria-expanded="false">All dates</button>
              <div class="profile-date-menu" id="profileDateMenu" role="listbox" aria-multiselectable="true" aria-label="Filter dates"></div>
            </div>
            <div class="profile-toolbar-actions">
              <button class="btn ghost" id="profileClearFilter" type="button">Show all dates</button>
              <button class="btn ghost" id="profileSelectShown" type="button">Select shown words</button>
              <button class="btn ghost" id="profileClearSelection" type="button">Clear selection</button>
            </div>
          </div>
          <div class="profile-table-wrap">
            <table class="profile-table" aria-describedby="profileTitle">
              <thead>
                <tr>
                  <th scope="col" style="width:40px"></th>
                  <th scope="col">Word in Hebrew</th>
                  <th scope="col">Word in English</th>
                  <th scope="col">Guesses</th>
                  <th scope="col">Date added</th>
                </tr>
              </thead>
              <tbody id="profileTableBody"></tbody>
            </table>
          </div>
          <div class="profile-footer">
            <div class="profile-selected-count" id="profileSelectedCount">No words selected.</div>
            <button class="btn" id="profilePlayBtn" type="button" disabled>Play with Selected Words</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="difficultyModal" role="dialog" aria-modal="true" aria-labelledby="difficultyTitle" aria-describedby="difficultySubtitle">
    <div class="modal-card difficulty-card">
      <button class="modal-close" id="difficultyClose" aria-label="Close">×</button>
      <h2 id="difficultyTitle">Choose your challenge</h2>
      <p class="auth-meta" id="difficultySubtitle">This controls how convincing the wrong answers will feel.</p>
      <div class="difficulty-options">
        <button class="difficulty-option" data-difficulty="easy">
          <span class="difficulty-label">Easy</span>
          <span class="difficulty-note">Distant distractors that make the answer stand out.</span>
        </button>
        <button class="difficulty-option" data-difficulty="medium">
          <span class="difficulty-label">Medium</span>
          <span class="difficulty-note">Related but still distinguishable options.</span>
        </button>
        <button class="difficulty-option" data-difficulty="hard">
          <span class="difficulty-label">Hard</span>
          <span class="difficulty-note">Near-miss distractors for maximum challenge.</span>
        </button>
      </div>
      <p class="difficulty-hint">(This setting shapes how obvious or sneaky the wrong answers feel—the harder the mode, the subtler the traps.)</p>
      <button class="btn ghost" id="difficultyCancel" type="button">Never mind</button>
    </div>
  </div>

  <!-- SETUP -->
  <div class="wrap" id="mainScreen">
    <h1>Hebrew ↔ English Flashcard Game</h1>
    <div class="row">
      <div class="col">
        <label>Word list
          <textarea id="raw" placeholder="Paste pairs like **שלום – hello** or **ללמוד – to study**, one per line."></textarea>
        </label>
      </div>
      <div class="col" style="align-self:flex-start;display:flex;flex-direction:column;gap:10px">
        <label>Mode
          <select id="mode">
            <option value="type">Type answer</option>
            <option value="flash">Flashcards (no typing)</option>
            <option value="mc4">Multiple choice (4 options)</option>
          </select>
        </label>
        <label>Direction
          <select id="direction">
            <option value="he2en">Hebrew → English</option>
            <option value="en2he">English → Hebrew</option>
            <option value="mixed">Mixed</option>
          </select>
        </label>
        <label>Level (auto‑detect)
          <select id="level">
            <option value="auto">Auto</option>
            <option value="beginner">Beginner</option>
            <option value="intermediate">Intermediate</option>
            <option value="advanced">Advanced</option>
          </select>
        </label>
        <div id="levelNote" class="chip">Level: —</div>
        <label>Shuffle
          <select id="shuffle">
            <option value="1">On</option>
            <option value="0">Off</option>
          </select>
        </label>
        <button class="btn" id="startBtn">Start game</button>
      </div>
    </div>
  </div>

  <!-- GAME (FULLSCREEN) -->
  <div class="game-screen" id="gameScreen">
    <div class="game-header">
      <button class="back-btn" id="backBtn" aria-label="Back">← Back</button>
      <div class="scorebar">
        <span>Score: <strong id="score">0</strong>/<span id="total">0</span></span>
        <span>Streak: <strong id="streak">0</strong></span>
        <span>Remaining: <strong id="remaining">0</strong></span>
        <span class="chip" id="dirChip">—</span>
        <span class="chip" id="liveLevel">—</span>
        <span class="chip" id="difficultyChip">Difficulty: —</span>
      </div>
      <div style="visibility:hidden">spacer</div>
    </div>
    <div class="game-body">
      <div class="bigcard">
        <div class="prompt" id="prompt">Paste your list and click Start</div>
        <div class="answer" id="answer"></div>
        <input id="userAnswer" type="text" placeholder="Type your answer… Enter" style="display:none">
        <div class="toolbar" id="flashBar" style="display:none">
          <button class="btn ghost" id="revealBtn">Show answer (Space)</button>
          <button class="btn" id="correctBtn" style="display:none">I was right (1)</button>
          <button class="btn danger" id="wrongBtn" style="display:none">I missed (2)</button>
          <button class="btn ghost" id="skipBtn">Skip</button>
        </div>
        <div class="toolbar" id="mcBar" style="display:none; gap:12px; flex-wrap:wrap; max-width:920px">
          <div id="mcGrid">
            <button class="mc-option" id="optA">A</button>
            <button class="mc-option" id="optB">B</button>
            <button class="mc-option" id="optC">C</button>
            <button class="mc-option" id="optD">D</button>
          </div>
          <button class="btn ok" id="nextBtn">Ready for the next word?</button>
        </div>
        <div class="toolbar">
          <span class="chip">Enter = check</span>
          <span class="chip">Space = reveal</span>
          <span class="chip">A/B/C/D or 1–4 = choose</span>
          <span class="chip">1/2 = mark</span>
          <span class="chip">Esc = back</span>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const mainScreen = $('mainScreen');
  const gameScreen = $('gameScreen');
  const backBtn = $('backBtn');
  const rawEl = $('raw');
  const startBtn = $('startBtn');
  const modeSel = $('mode');
  const dirSel = $('direction');
  const shuffleSel = $('shuffle');
  const levelSel = $('level');
  const levelNote = $('levelNote');
  const promptEl = $('prompt');
  const answerEl = $('answer');
  const userAnswer = $('userAnswer');
  const flashBar = $('flashBar');
  const revealBtn = $('revealBtn');
  const correctBtn = $('correctBtn');
  const wrongBtn = $('wrongBtn');
  const skipBtn = $('skipBtn');
  const mcBar = $('mcBar');
  const optA = $('optA');
  const optB = $('optB');
  const optC = $('optC');
  const optD = $('optD');
  const nextBtn = $('nextBtn');
  const scoreEl = $('score');
  const totalEl = $('total');
  const remainingEl = $('remaining');
  const streakEl = $('streak');
  const dirChip = $('dirChip');
  const liveLevel = $('liveLevel');
  const authOpenBtn = $('authOpenBtn');
  const signOutBtn = $('signOutBtn');
  const authGreeting = $('authGreeting');
  const authStatus = $('authStatus');
  const authModal = $('authModal');
  const loadingCover = $('loadingCover');
  const loadingText = $('loadingText');
  const loadingHint = $('loadingHint');
  const authForm = $('authForm');
  const authModalTitle = $('authModalTitle');
  const authModalSubtitle = $('authModalSubtitle');
  const authUsername = $('authUsername');
  const authPassword = $('authPassword');
  const authError = $('authError');
  const authSubmit = $('authSubmit');
  const authSwitch = $('authSwitch');
  const authSwitchPrompt = $('authSwitchPrompt');
  const authClose = $('authClose');
  const profileBtn = $('profileBtn');
  const difficultyModal = $('difficultyModal');
  const difficultyClose = $('difficultyClose');
  const difficultyCancel = $('difficultyCancel');
  const difficultyChip = $('difficultyChip');
  const difficultyOptions = Array.from(document.querySelectorAll('.difficulty-option'));
  const profileModal = $('profileModal');
  const profileClose = $('profileClose');
  const profileUsername = $('profileUsername');
  const profileWords = $('profileWords');
  const profileEmpty = $('profileEmpty');
  const profileShell = $('profileShell');
  const profileDateToggle = $('profileDateToggle');
  const profileDateMenu = $('profileDateMenu');
  const profileClearFilter = $('profileClearFilter');
  const profileSelectShown = $('profileSelectShown');
  const profileClearSelection = $('profileClearSelection');
  const profileTableBody = $('profileTableBody');
  const profilePlayBtn = $('profilePlayBtn');
  const profileSelectedCount = $('profileSelectedCount');
  let audioCtx;

  const USERS_KEY = 'hf_users_v1';
  const CURRENT_USER_KEY = 'hf_current_user';
  const authState = { mode:'signin', user:null };
  const profileState = { filterDates:new Set(), selected:new Set(), words:[], wordsByKey:new Map(), dateLabels:new Map() };

  function showLoading(statusText, hintText){
    if(statusText) loadingText.textContent = statusText;
    if(hintText) loadingHint.textContent = hintText;
    loadingCover.hidden = false;
  }
  function hideLoading(){
    loadingCover.hidden = true;
  }

  function resetProfileState(){
    profileState.filterDates.clear();
    profileState.selected.clear();
    profileState.words = [];
    profileState.wordsByKey.clear();
    profileState.dateLabels.clear();
    if(profileDateMenu){
      profileDateMenu.innerHTML = '';
      profileDateMenu.classList.remove('open');
    }
    if(profileDateToggle){
      profileDateToggle.textContent = 'All dates';
      profileDateToggle.disabled = true;
    }
    if(profileSelectShown){ profileSelectShown.disabled = true; }
    if(profileClearSelection){ profileClearSelection.disabled = true; }
    updateProfileSelectionUI();
  }

  function loadUsers(){
    try {
      const raw = localStorage.getItem(USERS_KEY);
      if(!raw) return [];
      const parsed = JSON.parse(raw);
      if(!Array.isArray(parsed)) return [];
      return parsed
        .filter(u=>u && typeof u.username==='string' && typeof u.password==='string')
        .map(u=>({
          username: u.username,
          password: u.password,
          words: Array.isArray(u.words) ? u.words.map(w=>normalizeWordEntry(w)) : []
        }));
    } catch(err){
      console.warn('Could not parse users from storage', err);
      return [];
    }
  }

  function canonicalKey(he, enList){
    const hePart = (he||'').toString().trim().toLowerCase();
    const list = Array.isArray(enList) ? enList : (enList ? [enList] : []);
    const normalized = list
      .map(val=>val==null?'':String(val).trim().toLowerCase())
      .filter(Boolean);
    const uniqueSorted = Array.from(new Set(normalized)).sort();
    return hePart + '||' + uniqueSorted.join('||');
  }

  function sanitizeEnList(value){
    const arr = Array.isArray(value) ? value : (value ? [value] : []);
    const seen = new Set();
    const cleaned = [];
    for(const entry of arr){
      if(entry==null) continue;
      const str = String(entry).trim();
      if(!str) continue;
      const key = str.toLowerCase();
      if(seen.has(key)) continue;
      seen.add(key);
      cleaned.push(str);
    }
    return cleaned;
  }

  function formatDateKey(ts){
    const d = new Date(ts || Date.now());
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${day}`;
  }

  function formatDateLabel(ts){
    const d = new Date(ts || Date.now());
    return d.toLocaleDateString(undefined, { year:'numeric', month:'short', day:'numeric' });
  }

  function normalizeWordEntry(entry){
    const parseCount = (value)=>{
      const num = Number(value);
      if(!Number.isFinite(num) || num < 0) return 0;
      return Math.floor(num);
    };
    if(!entry || typeof entry !== 'object'){
      const value = entry!=null ? String(entry) : '';
      const enList = value ? [value] : [];
      const key = canonicalKey(value, enList) || Math.random().toString(36).slice(2);
      return { key, he:value, en:enList, addedAt:Date.now(), guessedCorrect:0, guessedIncorrect:0 };
    }
    const he = typeof entry.he==='string' ? entry.he.trim() : '';
    const enList = sanitizeEnList(entry.en);
    const keyBase = entry.key && typeof entry.key==='string' && entry.key.trim() ? entry.key : canonicalKey(he, enList);
    return {
      key: keyBase || Math.random().toString(36).slice(2),
      he,
      en: enList,
      addedAt: entry.addedAt || Date.now(),
      guessedCorrect: parseCount(entry.guessedCorrect),
      guessedIncorrect: parseCount(entry.guessedIncorrect)
    };
  }

  function saveUsers(users){
    localStorage.setItem(USERS_KEY, JSON.stringify(users));
  }

  function setCurrentUser(username){
    if(username){
      localStorage.setItem(CURRENT_USER_KEY, username);
    } else {
      localStorage.removeItem(CURRENT_USER_KEY);
    }
  }

  function refreshAuth(){
    const current = localStorage.getItem(CURRENT_USER_KEY);
    const users = loadUsers();
    if(current){
      const found = users.find(u=>u.username === current);
      if(found){
        authState.user = { ...found, words: Array.isArray(found.words)? found.words.map(normalizeWordEntry) : [] };
      } else {
        authState.user = null;
        setCurrentUser(null);
      }
    } else {
      authState.user = null;
    }
    updateAuthUI();
  }

  function updateAuthUI(){
    if(authState.user){
      const count = Array.isArray(authState.user.words)? authState.user.words.length : 0;
      authGreeting.textContent = 'Welcome, ' + authState.user.username;
      authStatus.textContent = count ? `${count} saved word${count===1?'':'s'}.` : 'No saved words yet—start a game!';
      signOutBtn.style.display = 'block';
      profileBtn.style.display = 'inline-flex';
      authOpenBtn.textContent = 'Switch account';
    } else {
      authGreeting.textContent = 'Welcome, Guest';
      authStatus.textContent = 'Sign in to save your words.';
      signOutBtn.style.display = 'none';
      profileBtn.style.display = 'none';
      authOpenBtn.textContent = 'Sign in / Sign up';
      if(profileShell){ profileShell.hidden = true; }
      if(profileEmpty){
        profileEmpty.style.display = 'block';
        profileEmpty.textContent = 'Sign in to view your profile.';
      }
      if(profileUsername){ profileUsername.textContent = '—'; }
      resetProfileState();
    }
  }

  function setAuthMode(mode){
    authState.mode = mode;
    const isSignup = mode === 'signup';
    authModalTitle.textContent = isSignup ? 'Create account' : 'Sign in';
    authModalSubtitle.textContent = isSignup ? 'Choose a username and password to save your progress.' : 'Enter your credentials to continue.';
    authSubmit.textContent = isSignup ? 'Sign up' : 'Sign in';
    authSwitchPrompt.textContent = isSignup ? 'Already have an account?' : "Don't have an account?";
    authSwitch.textContent = isSignup ? 'Sign in' : 'Sign up';
    authPassword.value = '';
    authError.textContent = '';
  }

  function openModal(modal){ modal.classList.add('open'); }
  function closeModal(modal){ modal.classList.remove('open'); }

  function openAuthModal(mode){
    setAuthMode(mode);
    authError.textContent = '';
    authForm.reset();
    if(authState.user && mode==='signin'){
      authUsername.value = authState.user.username;
    }
    openModal(authModal);
    setTimeout(()=>{ authUsername.focus(); }, 50);
  }

  function hideAuthModal(){
    closeModal(authModal);
    authForm.reset();
    authError.textContent = '';
  }

  let difficultyResolver = null;

  function showDifficultyPicker(){
    if(!difficultyModal) return;
    openModal(difficultyModal);
    setTimeout(()=>{
      if(difficultyOptions.length){
        difficultyOptions[0].focus();
      }
    }, 30);
  }

  function settleDifficulty(choice){
    if(!difficultyModal) return;
    closeModal(difficultyModal);
    const resolver = difficultyResolver;
    difficultyResolver = null;
    if(typeof resolver === 'function'){
      resolver(choice ?? null);
    }
  }

  function requestDifficulty(){
    if(!difficultyModal) return Promise.resolve('hard');
    if(typeof difficultyResolver === 'function'){
      const resolver = difficultyResolver;
      difficultyResolver = null;
      resolver(null);
    }
    return new Promise(resolve=>{
      difficultyResolver = resolve;
      showDifficultyPicker();
    });
  }

  function handleAuthSubmit(){
    const username = authUsername.value.trim();
    const password = authPassword.value.trim();
    if(username.length < 3){ authError.textContent = 'Username must be at least 3 characters.'; return; }
    if(password.length < 4){ authError.textContent = 'Password must be at least 4 characters.'; return; }
    const users = loadUsers();
    if(authState.mode === 'signup'){
      const exists = users.find(u=>u.username.toLowerCase() === username.toLowerCase());
      if(exists){ authError.textContent = 'That username is already taken.'; return; }
      const newUser = { username, password, words: [] };
      users.push(newUser);
      saveUsers(users);
      setCurrentUser(username);
      authState.user = { ...newUser };
      resetProfileState();
      updateAuthUI();
      hideAuthModal();
    } else {
      const exists = users.find(u=>u.username === username);
      if(!exists || exists.password !== password){ authError.textContent = 'Invalid username or password.'; return; }
      setCurrentUser(exists.username);
      authState.user = { ...exists, words: Array.isArray(exists.words)? exists.words.map(normalizeWordEntry) : [] };
      resetProfileState();
      updateAuthUI();
      hideAuthModal();
    }
  }

  function renderProfile(){
    if(!authState.user){
      profileUsername.textContent = '—';
      if(profileShell) profileShell.hidden = true;
      if(profileEmpty){
        profileEmpty.style.display = 'block';
        profileEmpty.textContent = 'Sign in to view your profile.';
      }
      if(profileDateToggle) profileDateToggle.disabled = true;
      return;
    }
    profileUsername.textContent = authState.user.username;
    const words = Array.isArray(authState.user.words) ? authState.user.words.map(normalizeWordEntry) : [];
    const sorted = words.slice().sort((a,b)=>(b.addedAt||0)-(a.addedAt||0));
    profileState.words = sorted;
    profileState.wordsByKey = new Map(sorted.map(word=>[word.key, word]));
    const dateGroups = new Map();
    sorted.forEach(word=>{
      const key = formatDateKey(word.addedAt);
      if(!dateGroups.has(key)){
        dateGroups.set(key, { key, label: formatDateLabel(word.addedAt), words: [] });
      }
      dateGroups.get(key).words.push(word);
    });
    profileState.dateLabels = new Map(Array.from(dateGroups.values()).map(group=>[group.key, group.label]));
    for(const key of Array.from(profileState.filterDates)){
      if(!dateGroups.has(key)) profileState.filterDates.delete(key);
    }
    if(!sorted.length){
      if(profileShell) profileShell.hidden = true;
      if(profileEmpty){
        profileEmpty.style.display = 'block';
        profileEmpty.textContent = 'No words saved yet. Play a round to start collecting!';
      }
      if(profileDateToggle) profileDateToggle.disabled = true;
      profileState.selected.clear();
      updateProfileSelectionUI();
      updateDateToggleLabel();
      return;
    }
    if(profileEmpty) profileEmpty.style.display = 'none';
    if(profileShell) profileShell.hidden = false;
    if(profileDateToggle) profileDateToggle.disabled = false;
    buildDateMenu(Array.from(dateGroups.values()).sort((a,b)=>b.key.localeCompare(a.key)));
    renderProfileTable();
  }

  function buildDateMenu(groups){
    if(!profileDateMenu) return;
    profileDateMenu.innerHTML = '';
    profileDateMenu.classList.remove('open');
    if(profileDateToggle) profileDateToggle.disabled = groups.length===0;
    if(profileDateToggle) profileDateToggle.setAttribute('aria-expanded', 'false');
    if(!groups.length){
      updateDateToggleLabel();
      return;
    }
    const list = document.createElement('ul');
    groups.forEach(group=>{
      const item = document.createElement('li');
      const label = document.createElement('label');
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.value = group.key;
      checkbox.checked = profileState.filterDates.has(group.key);
      const text = document.createElement('span');
      text.textContent = group.label;
      const count = document.createElement('small');
      count.textContent = `${group.words.length} word${group.words.length===1?'':'s'}`;
      label.appendChild(checkbox);
      label.appendChild(text);
      label.appendChild(count);
      const selectBtn = document.createElement('button');
      selectBtn.type = 'button';
      selectBtn.className = 'profile-date-select';
      selectBtn.setAttribute('data-date-select', group.key);
      selectBtn.textContent = 'Select all';
      item.appendChild(label);
      item.appendChild(selectBtn);
      list.appendChild(item);
    });
    profileDateMenu.appendChild(list);
    updateDateToggleLabel();
  }

  function getFilteredWords(){
    if(!profileState.words.length) return [];
    if(!profileState.filterDates.size) return profileState.words;
    return profileState.words.filter(word=>profileState.filterDates.has(formatDateKey(word.addedAt)));
  }

  function cleanupProfileSelection(){
    for(const key of Array.from(profileState.selected)){
      if(!profileState.wordsByKey.has(key)){
        profileState.selected.delete(key);
      }
    }
  }

  function renderProfileTable(){
    if(!profileTableBody) return;
    cleanupProfileSelection();
    profileTableBody.innerHTML = '';
    const filtered = getFilteredWords();
    if(profileSelectShown){ profileSelectShown.disabled = filtered.length===0; }
    if(!filtered.length){
      const row = document.createElement('tr');
      const cell = document.createElement('td');
      cell.colSpan = 5;
      cell.textContent = profileState.words.length ? 'No words for the selected date(s).' : 'No words saved yet.';
      cell.style.textAlign = 'center';
      row.appendChild(cell);
      profileTableBody.appendChild(row);
      updateProfileSelectionUI();
      return;
    }
    filtered.forEach(word=>{
      const row = document.createElement('tr');
      row.setAttribute('data-key', word.key);
      const checkboxCell = document.createElement('td');
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = profileState.selected.has(word.key);
      checkbox.setAttribute('aria-label', `Select ${word.he || (Array.isArray(word.en)?word.en[0]:word.en) || 'word'}`);
      checkbox.addEventListener('change', ()=>{
        if(checkbox.checked){ profileState.selected.add(word.key); }
        else { profileState.selected.delete(word.key); }
        updateProfileSelectionUI();
      });
      checkboxCell.appendChild(checkbox);
      row.appendChild(checkboxCell);

      const heCell = document.createElement('td');
      heCell.textContent = word.he || '';
      heCell.setAttribute('dir', looksHebrew(word.he)?'rtl':'ltr');
      row.appendChild(heCell);

      const enCell = document.createElement('td');
      const enList = Array.isArray(word.en) ? word.en : [word.en];
      enCell.textContent = enList.filter(Boolean).join(' / ');
      row.appendChild(enCell);

      const guessesCell = document.createElement('td');
      const correctSpan = document.createElement('span');
      correctSpan.className = 'guess-count guess-correct';
      correctSpan.textContent = String(word.guessedCorrect || 0);
      const slashSpan = document.createElement('span');
      slashSpan.textContent = ' / ';
      const incorrectSpan = document.createElement('span');
      incorrectSpan.className = 'guess-count guess-incorrect';
      incorrectSpan.textContent = String(word.guessedIncorrect || 0);
      guessesCell.appendChild(correctSpan);
      guessesCell.appendChild(slashSpan);
      guessesCell.appendChild(incorrectSpan);
      row.appendChild(guessesCell);

      const dateCell = document.createElement('td');
      dateCell.textContent = formatDateLabel(word.addedAt);
      row.appendChild(dateCell);

      profileTableBody.appendChild(row);
    });
    updateProfileSelectionUI();
  }

  function updateDateToggleLabel(){
    if(!profileDateToggle) return;
    const count = profileState.filterDates.size;
    if(count===0){
      profileDateToggle.textContent = 'All dates';
      return;
    }
    if(count===1){
      const first = profileState.filterDates.values().next().value;
      profileDateToggle.textContent = profileState.dateLabels.get(first) || first;
      return;
    }
    profileDateToggle.textContent = `${count} dates`;
  }

  function updateProfileSelectionUI(){
    const count = profileState.selected.size;
    if(profilePlayBtn){
      profilePlayBtn.disabled = count===0;
      profilePlayBtn.textContent = count ? `Play with Selected Words (${count})` : 'Play with Selected Words';
    }
    if(profileSelectedCount){
      profileSelectedCount.textContent = count ? `${count} word${count===1?'':'s'} selected.` : 'No words selected.';
    }
    if(profileClearSelection){
      profileClearSelection.disabled = count===0;
    }
  }

  function closeProfileDateMenu(){
    if(profileDateMenu) profileDateMenu.classList.remove('open');
    if(profileDateToggle) profileDateToggle.setAttribute('aria-expanded', 'false');
  }

  function recordWordForUser(pair){
    if(!authState.user) return;
    const users = loadUsers();
    const idx = users.findIndex(u=>u.username === authState.user.username);
    if(idx === -1) return;
    const normalizedPair = normalizePairForDeck(pair);
    if(!normalizedPair.he || !normalizedPair.en.length) return;
    const key = canonicalKey(normalizedPair.he, normalizedPair.en);
    const words = Array.isArray(users[idx].words) ? users[idx].words.map(normalizeWordEntry) : [];
    const map = new Map(words.map(word=>[word.key, word]));
    if(map.has(key)){
      const existing = map.get(key);
      existing.he = normalizedPair.he;
      existing.en = normalizedPair.en;
      if(typeof existing.guessedCorrect !== 'number'){ existing.guessedCorrect = 0; }
      if(typeof existing.guessedIncorrect !== 'number'){ existing.guessedIncorrect = 0; }
      map.set(key, existing);
    } else {
      const entry = {
        key,
        he: normalizedPair.he,
        en: normalizedPair.en,
        addedAt: Date.now(),
        guessedCorrect: 0,
        guessedIncorrect: 0
      };
      map.set(key, entry);
    }
    const updatedWords = Array.from(map.values());
    users[idx].words = updatedWords;
    saveUsers(users);
    authState.user = { ...users[idx], words: updatedWords.slice() };
    updateAuthUI();
    if(profileModal.classList.contains('open')){ renderProfile(); }
  }

  function updateWordGuessStats(pair, wasCorrect){
    if(!authState.user) return;
    const users = loadUsers();
    const idx = users.findIndex(u=>u.username === authState.user.username);
    if(idx === -1) return;
    const normalizedPair = normalizePairForDeck(pair);
    if(!normalizedPair.he || !normalizedPair.en.length) return;
    const key = canonicalKey(normalizedPair.he, normalizedPair.en);
    const words = Array.isArray(users[idx].words) ? users[idx].words.map(normalizeWordEntry) : [];
    const map = new Map(words.map(word=>[word.key, word]));
    let entry = map.get(key);
    if(!entry){
      entry = {
        key,
        he: normalizedPair.he,
        en: normalizedPair.en,
        addedAt: Date.now(),
        guessedCorrect: 0,
        guessedIncorrect: 0
      };
    }
    if(wasCorrect){ entry.guessedCorrect = (entry.guessedCorrect || 0) + 1; }
    else { entry.guessedIncorrect = (entry.guessedIncorrect || 0) + 1; }
    map.set(key, entry);
    const updatedWords = Array.from(map.values());
    users[idx].words = updatedWords;
    saveUsers(users);
    authState.user = { ...users[idx], words: updatedWords.slice() };
    updateAuthUI();
    if(profileModal.classList.contains('open')){ renderProfile(); }
  }

  refreshAuth();

  authOpenBtn.addEventListener('click', ()=>{
    const existingUsers = loadUsers();
    const mode = authState.user ? 'signin' : (existingUsers.length ? 'signin' : 'signup');
    openAuthModal(mode);
  });

  authSwitch.addEventListener('click', ()=>{
    const nextMode = authState.mode === 'signin' ? 'signup' : 'signin';
    setAuthMode(nextMode);
  });

  authClose.addEventListener('click', hideAuthModal);
  authModal.addEventListener('click', (e)=>{ if(e.target === authModal) hideAuthModal(); });
  authForm.addEventListener('submit', (e)=>{ e.preventDefault(); handleAuthSubmit(); });
  signOutBtn.addEventListener('click', ()=>{ setCurrentUser(null); authState.user = null; updateAuthUI(); closeProfileDateMenu(); closeModal(profileModal); });

  if(difficultyClose){ difficultyClose.addEventListener('click', ()=> settleDifficulty(null)); }
  if(difficultyCancel){ difficultyCancel.addEventListener('click', ()=> settleDifficulty(null)); }
  if(difficultyModal){
    difficultyModal.addEventListener('click', (e)=>{ if(e.target === difficultyModal){ settleDifficulty(null); } });
  }
  if(difficultyOptions.length){
    difficultyOptions.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const value = btn.getAttribute('data-difficulty') || 'hard';
        settleDifficulty(value);
      });
    });
  }

  profileBtn.addEventListener('click', ()=>{ closeProfileDateMenu(); renderProfile(); openModal(profileModal); });
  profileClose.addEventListener('click', ()=>{ closeProfileDateMenu(); closeModal(profileModal); });
  profileModal.addEventListener('click', (e)=>{ if(e.target === profileModal){ closeProfileDateMenu(); closeModal(profileModal); } });

  if(profileDateToggle){
    profileDateToggle.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(profileDateMenu){
        const isOpen = profileDateMenu.classList.toggle('open');
        profileDateToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      }
    });
  }

  if(profileDateMenu){
    profileDateMenu.addEventListener('change', (e)=>{
      const target = e.target;
      if(target && target.matches('input[type="checkbox"]')){
        const key = target.value;
        if(target.checked){ profileState.filterDates.add(key); }
        else { profileState.filterDates.delete(key); }
        renderProfileTable();
        updateDateToggleLabel();
      }
    });
    profileDateMenu.addEventListener('click', (e)=>{
      const button = e.target.closest('button[data-date-select]');
      if(button){
        e.preventDefault();
        e.stopPropagation();
        const key = button.getAttribute('data-date-select');
        if(key){
          const matches = profileState.words.filter(word=>formatDateKey(word.addedAt)===key);
          matches.forEach(word=> profileState.selected.add(word.key));
          renderProfileTable();
        }
      }
    });
  }

  document.addEventListener('click', (e)=>{
    if(!profileDateMenu || !profileDateMenu.classList.contains('open')) return;
    if(profileDateMenu.contains(e.target)) return;
    if(profileDateToggle && profileDateToggle.contains(e.target)) return;
    closeProfileDateMenu();
  });

  if(profileClearFilter){
    profileClearFilter.addEventListener('click', ()=>{
      profileState.filterDates.clear();
      if(profileDateMenu){
        profileDateMenu.querySelectorAll('input[type="checkbox"]').forEach(cb=>{ cb.checked = false; });
      }
      updateDateToggleLabel();
      renderProfileTable();
      closeProfileDateMenu();
    });
  }

  if(profileSelectShown){
    profileSelectShown.addEventListener('click', ()=>{
      const filtered = getFilteredWords();
      if(!filtered.length) return;
      filtered.forEach(word=> profileState.selected.add(word.key));
      renderProfileTable();
    });
  }

  if(profileClearSelection){
    profileClearSelection.addEventListener('click', ()=>{
      if(!profileState.selected.size) return;
      profileState.selected.clear();
      if(profileTableBody){
        profileTableBody.querySelectorAll('tr[data-key] input[type="checkbox"]').forEach(cb=>{ cb.checked = false; });
      }
      updateProfileSelectionUI();
    });
  }

  if(profilePlayBtn){
    profilePlayBtn.addEventListener('click', async ()=>{
      const selectedWords = profileState.words.filter(word=>profileState.selected.has(word.key));
      if(!selectedWords.length) return;
      const deck = selectedWords.map(word=>({ he: word.he, en: Array.isArray(word.en) ? word.en.slice() : sanitizeEnList(word.en) }));
      rawEl.value = deck.map(word=>`${word.he} - ${word.en.join(', ')}`).join('\n');
      closeProfileDateMenu();
      closeModal(profileModal);
      let difficultyChoice = 'hard';
      if(modeSel.value === 'mc4'){
        difficultyChoice = await requestDifficulty();
        if(!difficultyChoice) return;
      }
      state.difficulty = difficultyChoice || 'hard';
      await beginGame(deck);
    });
  }

  // --- Utils ---
  function looksHebrew(s){ return /[\u0590-\u05FF]/.test(s||''); }
  function stripStars(s){ if(!s) return ''; return s.replace(/\*\*/g,'').trim().replace(/^\*+\s*/, '').replace(/\s*\*+$/, '').trim(); }
  function noNiqqud(s){ return (s||'').normalize('NFKD').replace(/[\u0591-\u05C7]/g,''); }
  function similarity(a,b){
    a = noNiqqud(a||'').toLowerCase(); b = noNiqqud(b||'').toLowerCase();
    if(!a||!b) return 0;
    let score = 0;
    if(a[0]===b[0]) score += 0.3; // same first letter
    const lenDiff = Math.abs(a.length-b.length); score += Math.max(0, 0.4 - 0.05*lenDiff);
    const bigr = (t)=> new Set(Array.from({length:Math.max(0,t.length-1)}, (_,i)=>t.slice(i,i+2)));
    const A = bigr(a), B = bigr(b);
    let inter = 0; A.forEach(x=>{ if(B.has(x)) inter++; });
    const j = A.size? inter / A.size : 0; score += 0.3*j;
    return score; // 0..1
  }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
  function setDir(el, text){ el.setAttribute('dir', looksHebrew(text)?'rtl':'ltr'); }
  function normalize(s){ return (s||'').toString().trim(); }

  function formatDifficultyLabel(value){
    if(!value) return '—';
    const lower = String(value).toLowerCase();
    return lower.charAt(0).toUpperCase() + lower.slice(1);
  }

  function updateDifficultyChip(){
    if(!difficultyChip) return;
    if(state.mode === 'mc4'){
      difficultyChip.textContent = 'Difficulty: ' + formatDifficultyLabel(state.difficulty);
    } else {
      difficultyChip.textContent = 'Difficulty: —';
    }
  }

  function normalizePairForDeck(pair){
    if(!pair) return { he:'', en:[] };
    const he = typeof pair.he==='string' ? pair.he.trim() : '';
    const enList = sanitizeEnList(pair.en);
    return { he, en: enList };
  }

  function normalizeDeck(deck){
    return (Array.isArray(deck)?deck:[])
      .map(normalizePairForDeck)
      .filter(pair=>pair.he && pair.en.length);
  }

  // --- Parsing ---
  function parseRaw(text){
    const lines = (text||'').split(/\r?\n/);
    const sep = /\s*[-–—]\s*/; // hyphen / en-/em-dash
    const out = [];
    for(const line of lines){
      if(!line.trim()) continue;
      const parts = stripStars(line).split(sep);
      if(parts.length < 2) continue;
      const left = stripStars(parts.shift().trim());
      const right = stripStars(parts.join(' - ').trim());
      const heFirst = looksHebrew(left) || (!looksHebrew(right));
      const he = heFirst ? left : right;
      const enSide = heFirst ? right : left;
      const enList = enSide.split(',').map(s=>stripStars(s)).filter(Boolean);
      out.push({ he, en: enList.length? enList : [enSide] });
    }
    return out;
  }

  // --- Level detection ---
  function detectLevel(deck){
    if(!deck.length) return 'beginner';
    const n = deck.length;
    const multiHe = deck.filter(p=>/\s/.test(p.he)).length / n; // phrases
    const avgHeLen = deck.reduce((a,p)=>a+noNiqqud(p.he).length,0)/n;
    const infCount = deck.filter(p=>/^ל[\u0590-\u05FF]/.test(p.he)).length; // infinitives
    const avgEnLen = deck.reduce((a,p)=>a+(p.en[0]||'').length,0)/n;
    let score = 0;
    score += multiHe*0.4; // more phrases → harder
    score += Math.min(1, (avgHeLen-4)/6)*0.3; // longer words → harder
    score += Math.min(1, infCount/n)*0.2; // verbs → a bit harder
    score += Math.min(1, (avgEnLen-4)/8)*0.1;
    if(score < 0.35) return 'beginner';
    if(score < 0.65) return 'intermediate';
    return 'advanced';
  }

  // --- Variant generators (offline, heuristic) ---
  const hebrewLookalikeMap = { 'א':'ע', 'ע':'א', 'ה':'ח', 'ח':'כ', 'כ':'ח', 'ג':'ק', 'ת':'ט', 'ס':'ש', 'ש':'ס', 'ב':'ו', 'ו':'ב' };
  function hebrewVariants(word){
    let w = noNiqqud(word).trim();
    const vars = new Set();
    // add/remove ה prefix
    if(!/^ה/.test(w)) vars.add('ה'+w); else vars.add(w.replace(/^ה/,''));
    // swap one similar letter
    for(let i=0;i<w.length;i++){
      const ch = w[i];
      if(hebrewLookalikeMap[ch]){
        vars.add(w.slice(0,i)+hebrewLookalikeMap[ch]+w.slice(i+1));
      }
    }
    // add common preposition prefixes
    ['ב','ל','מ'].forEach(pref=> vars.add(pref+w));
    return Array.from(vars).filter(x=>x!==w);
  }
  function englishVariants(phrase){
    const p = phrase.trim();
    const vars = new Set();
    // add/remove infinitive marker "to"
    if(/^to\s+/i.test(p)) vars.add(p.replace(/^to\s+/i,'')); else vars.add('to '+p);
    // pluralize simple nouns
    p.split(/\s+/).forEach(tok=>{
      if(/^[a-z]{3,}$/i.test(tok)){
        if(/y$/i.test(tok)) vars.add(p.replace(tok, tok.replace(/y$/i,'ies')));
        else if(!/s$/i.test(tok)) vars.add(p.replace(tok, tok+'s'));
      }
    });
    // verb endings
    if(/^[a-z]{3,}$/i.test(p)){
      vars.add(p+'ing'); vars.add(p+'ed');
    }
    return Array.from(vars).filter(x=>x.toLowerCase()!==p.toLowerCase());
  }

  const EN_SEMANTIC_BANK = {
    'study':['to learn','homework','lesson','study time'],
    'to study':['to learn','practice studying','prepare homework','review the lesson'],
    'learn':['to study','to understand','lesson','learning time'],
    'to learn':['to study','to practice','to understand better','learning session'],
    'read':['to skim','story time','reading practice','to look at words'],
    'to read':['reading practice','to go through a story','to study a book','reading homework'],
    'write':['essay','journal','to jot down','writing practice'],
    'to write':['writing practice','to take notes','essay work','to jot sentences'],
    'eat':['meal','snack','breakfast','to taste food'],
    'to eat':['have a meal','to taste food','lunchtime','snack break'],
    'drink':['beverage','glass of water','juice','to sip'],
    'to drink':['to sip','water break','cup of tea','beverage time'],
    'work':['job','office task','assignment','employment'],
    'to work':['job time','to do a task','office work','shift'],
    'play':['game','sport','recess','fun time'],
    'to play':['recess','game time','to have fun','practice game'],
    'run':['sprint','race','track practice','jog'],
    'to run':['to sprint','race practice','jogging','track workout'],
    'walk':['stroll','hike','slow walk','morning walk'],
    'to walk':['slow walk','evening stroll','go on foot','morning walk'],
    'house':['home','apartment','family house','living room'],
    'home':['house','apartment','family home','cozy room'],
    'family':['parents','relatives','siblings','home life'],
    'mother':['mom','parent','mother figure','mommy'],
    'father':['dad','parent','father figure','daddy'],
    'brother':['sibling','family member','older brother','younger brother'],
    'sister':['sibling','family member','older sister','younger sister'],
    'friend':['buddy','pal','classmate','best friend'],
    'teacher':['instructor','mentor','school guide','class teacher'],
    'student':['pupil','learner','classmate','kid in class'],
    'book':['story','novel','textbook','library book'],
    'school':['classroom','lesson','teacher','school building'],
    'city':['town','village','capital city','busy streets'],
    'market':['store','shop','grocery','bazaar'],
    'food':['meal','dish','snack','dinner'],
    'water':['drink','river water','glass of water','bottle of water'],
    'music':['song','melody','concert','tune'],
    'song':['melody','music','lyrics','tune'],
    'game':['sport','contest','board game','match'],
    'light':['lamp','sunlight','bright light','flashlight'],
    'dark':['night','shadow','dim light','no light'],
    'day':['morning','afternoon','sunny day','weekday'],
    'night':['evening','midnight','bedtime','dark night'],
    'happy':['glad','joyful','smiling','excited'],
    'sad':['unhappy','upset','blue mood','tearful'],
    'big':['large','huge','giant','massive'],
    'small':['tiny','little','mini','compact'],
    'fast':['quick','rapid','speedy','swift'],
    'slow':['sluggish','not fast','gradual','steady'],
    'hot':['warm','scorching','heat wave','very warm'],
    'cold':['chilly','freezing','ice cold','cool weather'],
    'cat':['kitten','pet cat','little cat','house pet'],
    'dog':['puppy','pet dog','guard dog','friendly dog'],
    'money':['cash','coins','allowance','salary'],
    'shop':['store','market','boutique','shopping trip'],
    'travel':['journey','trip','vacation','tour'],
    'to travel':['journey','take a trip','go on vacation','tour'],
    'speak':['talk','conversation','chat','discussion'],
    'to speak':['to talk','conversation','class discussion','oral practice'],
    'listen':['hear','audio practice','pay attention','listening time'],
    'to listen':['hear carefully','audio practice','pay attention','listening exercise']
  };

  const EN_FALLBACK = [
    'extra practice','similar idea','close meaning','related word','class activity','homework time','after-school lesson',
    'study partner','long conversation','friendly visit','family trip','daily routine','weekend plan'
  ];

  const HE_SEMANTIC_BANK = {
    'שלום':['היי','מה נשמע','ברכה','שלום לך'],
    'להתראות':['נתראה','שלום שלום','ביי','להיפגש שוב'],
    'ללמוד':['לשנן','לקרוא','שיעור','למידה'],
    'לקרוא':['קריאה','ספר','עיון','סיפור'],
    'לכתוב':['כתיבה','רשימה','עט','משימה'],
    'לחשוב':['מחשבה','להרהר','רעיון','ראש'],
    'לדבר':['שיחה','לשוחח','לומר','דיבור'],
    'לאכול':['ארוחה','מאכל','מנה','סעודה'],
    'לשתות':['שתייה','כוס מים','משקה','בקבוק'],
    'לעבוד':['עבודה','תפקיד','משרד','פרנסה'],
    'לשחק':['משחק','כדורגל','תחרות','זמן משחק'],
    'לרוץ':['ריצה','מסלול','ספרינט','מרוץ'],
    'ללכת':['הליכה','צעד','טיול','לצעוד'],
    'בית':['דירה','חדר','בית גדול','משפחה'],
    'ספר':['חוברת','סיפור','טקסט','ספר לימוד'],
    'כיתה':['כיתה לימודית','שיעור','חדר','בית ספר'],
    'בית ספר':['כיתה','מורה','שיעור','למידה'],
    'משפחה':['הורים','אחים','בית','משפחתיות'],
    'אמא':['אמא שלי','אם','הורה','אימהות'],
    'אבא':['אבא שלי','אב','הורה','אבהות'],
    'אח':['אחים','משפחה','בן','בן משפחה'],
    'אחות':['אחיות','משפחה','בת','בת משפחה'],
    'חבר':['ידיד','בן כיתה','חברות','חבר טוב'],
    'תלמיד':['חניך','לומד','סטודנט','תלמידה'],
    'מורה':['מחנך','מדריך','מורת דרך','מורה בבית ספר'],
    'עיר':['עיירה','רחובות','מרכז','מטרופולין'],
    'כפר':['מושב','עיירה קטנה','קהילה','שדות'],
    'אוכל':['מאכל','מנות','ארוחה','מטבח'],
    'מים':['שתייה','מים קרים','בקבוק','כוס'],
    'שיר':['מנגינה','מוזיקה','קצב','שירה'],
    'משחק':['תחרות','ספורט','לשחק','משחק ילדים'],
    'יום':['בוקר','צהריים','יום לימודים','יום שמשי'],
    'לילה':['ערב','חצות','שעת שינה','לילה חשוך'],
    'גדול':['ענק','רחב','גדול מאוד','גבוה'],
    'קטן':['זעיר','קטנטן','מיניאטורי','קטן מאוד'],
    'חם':['לוהט','חמים','שרב','חום'],
    'קר':['קריר','קפוא','שלג','קר מאוד'],
    'מהר':['זריז','במהירות','מהר מהר','ריצה'],
    'לאט':['באיטיות','איטי','צעד איטי','להאט'],
    'ילד':['נער','בן','תלמיד','ילדות'],
    'ילדה':['נערה','בת','תלמידה','ילדות'],
    'עבודה':['משרד','תפקיד','עובד','עבודה קשה'],
    'כסף':['מטבעות','שטרות','תשלום','חיסכון'],
    'נסיעה':['טיול','לנסוע','אוטובוס','דרך'],
    'לנסוע':['נסיעה','טיול','אוטובוס','רכבת'],
    'לאהוב':['אהבה','חיבה','לב','לייק'],
    'לשבת':['ישיבה','כיסא','לשבת בשקט','מנוחה'],
    'לפתוח':['פתיחה','דלת','מפתח','להתחיל'],
    'לסגור':['סגירה','דלת','נעילה','להפסיק']
  };

  const HE_FALLBACK = [
    'מילה דומה','רעיון קרוב','עוד תשובה אפשרית','חזרה על החומר','שיעור בכיתה','תרגול נוסף','בחירת מורה','תשובת תלמיד'
  ];

  const STOP_WORDS = new Set(['to','the','a','an','my','your','his','her','their','our']);

  const remoteAssociations = { en:new Map(), he:new Map() };
  const MAX_REMOTE_TARGETS = 24;

  function englishKeyParts(phrase){
    const base = (phrase||'').toLowerCase().trim();
    if(!base) return [];
    const tokens = base.split(/\s+/).filter(Boolean);
    const keys = new Set();
    keys.add(base);
    if(tokens[0]==='to' && tokens.length>1){
      const rest = tokens.slice(1).join(' ');
      keys.add(rest);
      keys.add(tokens[1]);
    }
    tokens.forEach(tok=>{ if(!STOP_WORDS.has(tok)) keys.add(tok); });
    return Array.from(keys).filter(Boolean);
  }

  function hebrewKeyParts(word){
    const base = noNiqqud(word||'').trim();
    if(!base) return [];
    const keys = new Set([base]);
    base.split(/[\s,/]+/).forEach(part=>{ if(part) keys.add(part); });
    if(/^ל/.test(base) && base.length>2){
      keys.add(base.replace(/^ל/,''));
    }
    return Array.from(keys);
  }

  async function fetchWithTimeout(url, timeout=4500){
    if(typeof fetch!=='function'){
      console.warn('Fetch API is not available in this environment.');
      return null;
    }
    const controller = typeof AbortController!=='undefined' ? new AbortController() : null;
    const timer = controller ? setTimeout(()=>controller.abort(), timeout) : null;
    try{
      const res = await fetch(url, controller ? { signal: controller.signal } : undefined);
      if(!res.ok) throw new Error('Network error '+res.status);
      const data = await res.json();
      return data;
    } catch(err){
      console.warn('Remote lookup failed for', url, err);
      return null;
    } finally {
      if(timer) clearTimeout(timer);
    }
  }

  function collectWordsFromSet(set, key, values){
    const seen = set.get(key) || [];
    if(!values || !values.length){
      if(!set.has(key)) set.set(key, []);
      return seen;
    }
    const unique = new Set(seen.map(x=>x.toLowerCase()));
    values.forEach(val=>{
      let norm = (val||'').toString().replace(/[_]+/g,' ');
      norm = normalize(norm);
      if(!norm) return;
      const lower = norm.toLowerCase();
      if(lower===key) return;
      if(unique.has(lower)) return;
      unique.add(lower);
      seen.push(norm);
    });
    if(seen.length>24) seen.length = 24;
    set.set(key, seen);
    return seen;
  }

  async function fetchEnglishAssociations(term){
    const key = term.trim().toLowerCase();
    if(!key) return [];
    if(remoteAssociations.en.has(key)) return remoteAssociations.en.get(key);
    const clean = key.replace(/[^\p{L}\s'-]/gu,' ').replace(/\s+/g,' ').trim();
    if(!clean){
      remoteAssociations.en.set(key, []);
      return [];
    }
    const endpoints = [
      `https://api.datamuse.com/words?ml=${encodeURIComponent(clean)}&max=10`,
      `https://api.datamuse.com/words?rel_trg=${encodeURIComponent(clean)}&max=8`,
      `https://api.datamuse.com/words?sl=${encodeURIComponent(clean)}&max=6`
    ];
    const payloads = await Promise.all(endpoints.map(url=>fetchWithTimeout(url)));
    const collected = [];
    payloads.forEach(payload=>{
      if(Array.isArray(payload)){
        payload
          .slice()
          .sort((a,b)=> (b && b.score || 0) - (a && a.score || 0))
          .forEach(entry=>{
            const word = entry && entry.word ? entry.word : '';
            if(word) collected.push(word);
          });
      }
    });
    const stored = collectWordsFromSet(remoteAssociations.en, key, collected);
    return stored;
  }

  async function fetchHebrewAssociations(term){
    const key = noNiqqud(term||'').trim();
    if(!key) return [];
    if(remoteAssociations.he.has(key)) return remoteAssociations.he.get(key);
    const encoded = encodeURIComponent(key);
    const endpoints = [
      `https://api.datamuse.com/words?ml=${encoded}&v=he&max=10`,
      `https://api.datamuse.com/words?rel_trg=${encoded}&v=he&max=8`,
      `https://api.datamuse.com/words?sl=${encoded}&v=he&max=6`
    ];
    const payloads = await Promise.all(endpoints.map(url=>fetchWithTimeout(url)));
    const collected = [];
    payloads.forEach(payload=>{
      if(Array.isArray(payload)){
        payload
          .slice()
          .sort((a,b)=> (b && b.score || 0) - (a && a.score || 0))
          .forEach(entry=>{
            const word = entry && entry.word ? entry.word : '';
            if(word) collected.push(word);
          });
      }
    });
    const stored = collectWordsFromSet(remoteAssociations.he, key, collected);
    return stored;
  }

  async function gatherRemoteAssociations(deck){
    if(!Array.isArray(deck) || !deck.length) return;
    const heTargets = new Set();
    const enTargets = new Set();
    deck.forEach(pair=>{
      if(pair.he){
        hebrewKeyParts(pair.he).forEach(key=>{ if(key && !remoteAssociations.he.has(key)) heTargets.add(key); });
      }
      (pair.en||[]).forEach(en=>{
        englishKeyParts(en).forEach(key=>{
          if(key && !remoteAssociations.en.has(key)) enTargets.add(key);
        });
      });
    });
    const heList = Array.from(heTargets).slice(0, MAX_REMOTE_TARGETS);
    const enList = Array.from(enTargets).slice(0, MAX_REMOTE_TARGETS);
    const tasks = [];
    heList.forEach(key=> tasks.push(fetchHebrewAssociations(key)));
    enList.forEach(key=> tasks.push(fetchEnglishAssociations(key)));
    if(!tasks.length) return;
    const totalTargets = heList.length + enList.length;
    const hint = totalTargets>0
      ? `Querying ${totalTargets} word families for near-miss distractors…`
      : 'Reaching out to lexical services for sharper distractors.';
    showLoading('Collecting connected words…', hint);
    try{
      if(typeof Promise.allSettled==='function'){
        await Promise.allSettled(tasks);
      } else {
        await Promise.all(tasks.map(p=>p.catch(()=>null)));
      }
    } finally {
      hideLoading();
    }
  }

  function englishSemanticAlternatives(phrase){
    const ordered = [];
    const seen = new Set();
    const add = (value)=>{
      const norm = normalize(value);
      if(!norm) return;
      const lower = norm.toLowerCase();
      if(seen.has(lower)) return;
      seen.add(lower);
      ordered.push(norm);
    };
    const pieces = (phrase||'').split(/[/,]/).map(part=>part.trim()).filter(Boolean);
    if(!pieces.length) pieces.push(phrase||'');
    pieces.forEach(part=>{
      const lower = part.toLowerCase();
      const tokens = lower.split(/\s+/).filter(Boolean);
      const keys = new Set();
      if(tokens.length){
        keys.add(lower);
        if(tokens[0]==='to' && tokens.length>1){
          keys.add('to '+tokens[1]);
          keys.add(tokens[1]);
        }
        tokens.forEach(tok=>{ if(!STOP_WORDS.has(tok)) keys.add(tok); });
      }
      keys.forEach(key=>{
        const remote = remoteAssociations.en.get(key);
        if(Array.isArray(remote)) remote.forEach(add);
        if(EN_SEMANTIC_BANK[key]){
          EN_SEMANTIC_BANK[key].forEach(add);
        }
      });
      if(tokens[0]==='to' && tokens.length>1){
        const base = tokens.slice(1).join(' ');
        if(base){
          add('to practice '+base);
          add('to review '+base);
          add('practice '+base);
        }
      } else if(tokens.length===1 && tokens[0]){
        const word = tokens[0];
        add('about '+word);
        add(word+' lesson');
      }
    });
    return ordered;
  }

  function hebrewSemanticAlternatives(word){
    const base = noNiqqud(word||'').trim();
    if(!base) return [];
    const parts = base.split(/[\s,/]+/).filter(Boolean);
    const keys = new Set([base, ...parts]);
    const results = new Set();
    keys.forEach(key=>{
      const remote = remoteAssociations.he.get(key);
      if(Array.isArray(remote)){
        remote.forEach(option=>{ if(option) results.add(option); });
      }
      if(HE_SEMANTIC_BANK[key]){
        HE_SEMANTIC_BANK[key].forEach(option=>{ if(option) results.add(option); });
      }
    });
    if(/^ל/.test(base) && base.length>2){
      const stem = base.replace(/^ל/, '');
      results.add('עוד '+stem);
      results.add('תרגול '+stem);
    }
    return Array.from(results);
  }

  // --- State ---
  const state = { deck:[], queue:[], i:0, score:0, streak:0, dir:'he2en', mode:'type', revealed:false, mc:{choices:[], correctIndex:-1}, level:'beginner', difficulty:'hard', seen:new Set(), currentIdx:null, currentPair:null };

  function buildQueue(){
    state.queue = state.deck.map((_,i)=>i);
    if(shuffleSel.value==='1') shuffle(state.queue);
    state.i=0; state.score=0; state.streak=0; state.revealed=false;
    state.seen = new Set();
    state.currentIdx = null;
    state.currentPair = null;
    totalEl.textContent = state.queue.length;
    remainingEl.textContent = state.queue.length;
  }
  function nextDirection(){ return dirSel.value==='mixed' ? (Math.random()>0.5?'he2en':'en2he') : dirSel.value; }

  async function beginGame(deck){
    const normalizedDeck = normalizeDeck(deck);
    if(!normalizedDeck.length){
      alert('Please include at least one valid word pair.');
      return;
    }
    const desiredLevel = levelSel.value==='auto' ? detectLevel(normalizedDeck) : levelSel.value;
    state.level = desiredLevel;
    levelNote.textContent = 'Level: ' + desiredLevel;
    liveLevel.textContent = 'Level: ' + desiredLevel;
    await gatherRemoteAssociations(normalizedDeck);
    state.mode = modeSel.value;
    updateDifficultyChip();
    state.deck = normalizedDeck;
    buildQueue();
    mainScreen.style.display='none';
    gameScreen.style.display='block';
    showCard();
  }

  function hideAllUI(){
    userAnswer.style.display='none';
    flashBar.style.display='none';
    mcBar.style.display='none';
    revealBtn.style.display='inline-block';
    correctBtn.style.display='none';
    wrongBtn.style.display='none';
    nextBtn.style.display='none';
    nextBtn.onclick = null;
  }

  function showCard(){
    if(state.i >= state.queue.length){
      promptEl.textContent = '🎉 Done!'; answerEl.textContent=''; hideAllUI(); return;
    }
    const idx = state.queue[state.i];
    const pair = state.deck[idx];
    state.currentIdx = idx;
    state.currentPair = pair;
    state.dir = nextDirection();
    const promptText = state.dir==='he2en' ? pair.he : (pair.en[0]||'');
    const answerText = state.dir==='he2en' ? pair.en.join(' / ') : pair.he;

    if(!state.seen.has(idx)){
      state.seen.add(idx);
      recordWordForUser(pair);
    }

    hideAllUI();
    state.revealed = false;
    promptEl.textContent = promptText; setDir(promptEl, promptText);
    answerEl.textContent = '';
    dirChip.textContent = state.dir==='he2en' ? 'Heb → Eng' : 'Eng → Heb';
    liveLevel.textContent = 'Level: ' + state.level.charAt(0).toUpperCase()+state.level.slice(1);
    updateDifficultyChip();

    if(state.mode==='type'){
      userAnswer.value=''; userAnswer.style.display='block'; userAnswer.focus();
      userAnswer.onkeydown = (e)=>{ if(e.key==='Enter'){ checkTyped(answerText); } };
    } else if(state.mode==='flash'){
      flashBar.style.display='flex';
    } else if(state.mode==='mc4'){
      buildMC(answerText, idx);
    }
  }

  function reveal(answerText){
    if(state.revealed) return;
    state.revealed = true;
    answerEl.textContent = answerText;
    revealBtn.style.display='none';
    correctBtn.style.display='inline-block';
    wrongBtn.style.display='inline-block';
  }

  function mark(correct){
    if(state.currentPair){ updateWordGuessStats(state.currentPair, correct); }
    if(correct){ state.score++; state.streak++; }
    else { state.streak=0; const idx = state.queue[state.i]; const againAt = Math.min(state.queue.length, state.i + 3 + Math.floor(Math.random()*3)); state.queue.splice(againAt,0,idx); }
    scoreEl.textContent = state.score; streakEl.textContent = state.streak;
    state.i++; remainingEl.textContent = Math.max(0, state.queue.length - state.i);
    showCard();
  }

  function checkTyped(correct){
    const guess = userAnswer.value.trim();
    const normalizedCorrect = correct.toLowerCase();
    const isCorrect = normalizedCorrect.split('/').map(s=>s.trim()).includes(guess.toLowerCase());
    answerEl.textContent = (isCorrect?'✓ ':'✗ ') + correct.split('/')[0].trim();
    mark(isCorrect);
  }

  // --- MC (smart, level‑aware) ---
  function buildMC(answerText, currentIdx){
    mcBar.style.display='flex';
    const promptIsHeb = state.dir==='he2en';
    const pair = state.deck[currentIdx] || {};
    const primary = promptIsHeb
      ? (Array.isArray(pair.en) && pair.en.length ? pair.en[0] : pair.en)
      : pair.he;
    const correct = answerText;
    const comparisonTarget = normalize(primary) || correct;

    const pool = [];
    for(let i=0;i<state.deck.length;i++){
      if(i===currentIdx) continue;
      const p = state.deck[i];
      if(promptIsHeb){
        const options = Array.isArray(p.en) ? p.en : [p.en];
        options.forEach(opt=>{ if(opt) pool.push(opt); });
      } else if(p.he){
        pool.push(p.he);
      }
    }

    const semantic = promptIsHeb ? englishSemanticAlternatives(comparisonTarget) : hebrewSemanticAlternatives(comparisonTarget);
    const gens = promptIsHeb ? englishVariants(comparisonTarget) : hebrewVariants(comparisonTarget);

    const distractors = [];
    const used = new Set();
    const correctKey = normalize(correct).toLowerCase();
    used.add(correctKey);
    const primaryKey = normalize(comparisonTarget).toLowerCase();
    if(primaryKey && primaryKey!==correctKey) used.add(primaryKey);

    function tryAdd(x){
      const n = normalize(x).toLowerCase();
      if(!n || used.has(n)) return false;
      distractors.push(x);
      used.add(n);
      return true;
    }

    const difficulty = state.mode==='mc4' ? (state.difficulty || 'hard') : 'hard';
    const scoreFor = (value)=>{
      const norm = normalize(value);
      if(!norm) return 0;
      return similarity(norm, comparisonTarget);
    };
    const ranked = pool.map(x=>({ x, s: scoreFor(x) }));
    const closeFirst = ranked.slice().sort((a,b)=>b.s-a.s).map(r=>r.x);
    const midFirst = ranked.slice().sort((a,b)=>Math.abs(0.45-b.s)-Math.abs(0.45-a.s)).map(r=>r.x);
    const farFirst = ranked.slice().sort((a,b)=>a.s-b.s).map(r=>r.x);
    const randomPool = shuffle(pool.slice());
    const fallbackList = (promptIsHeb ? EN_FALLBACK : HE_FALLBACK).slice();

    function filterSimilarity(list, tier){
      if(!Array.isArray(list) || !list.length) return [];
      const filtered = list.filter(item=>{
        const score = scoreFor(item);
        if(tier==='easy') return score <= 0.35;
        if(tier==='medium') return score >= 0.2 && score <= 0.65;
        if(tier==='hard') return score >= 0.4;
        return true;
      });
      return filtered.length ? filtered : [];
    }

    const candidateLists = [];
    if(difficulty === 'easy'){
      const easyRemote = filterSimilarity(semantic.concat(gens), 'easy');
      if(easyRemote.length) candidateLists.push(easyRemote);
      if(farFirst.length) candidateLists.push(farFirst);
      const distantPool = randomPool.filter(option=> scoreFor(option) <= 0.35);
      if(distantPool.length) candidateLists.push(distantPool);
      candidateLists.push(fallbackList.slice());
    } else if(difficulty === 'medium'){
      const mediumSemantic = filterSimilarity(semantic, 'medium');
      if(mediumSemantic.length) candidateLists.push(mediumSemantic);
      const mediumGens = filterSimilarity(gens, 'medium');
      if(mediumGens.length) candidateLists.push(mediumGens);
      if(midFirst.length) candidateLists.push(midFirst);
      const mediumPool = randomPool.filter(option=>{
        const score = scoreFor(option);
        return score >= 0.2 && score <= 0.65;
      });
      if(mediumPool.length) candidateLists.push(mediumPool);
      if(closeFirst.length) candidateLists.push(closeFirst);
      candidateLists.push(fallbackList.slice());
    } else {
      if(semantic.length) candidateLists.push(semantic);
      if(gens.length) candidateLists.push(gens);
      if(closeFirst.length) candidateLists.push(closeFirst);
      if(midFirst.length) candidateLists.push(midFirst);
      if(randomPool.length) candidateLists.push(randomPool);
    }

    candidateLists.forEach(list=>{
      for(const item of list){
        if(tryAdd(item) && distractors.length>=3) break;
      }
    });

    if(distractors.length<3){
      const fallbackPool = shuffle(fallbackList.slice());
      for(const option of fallbackPool){
        if(tryAdd(option) && distractors.length>=3) break;
      }
    }

    if(distractors.length<3 && pool.length){
      const extras = shuffle(pool.slice());
      for(const option of extras){
        if(tryAdd(option) && distractors.length>=3) break;
      }
    }

    let fillerCount = 1;
    while(distractors.length<3){
      const label = promptIsHeb ? `תשובה קרובה ${fillerCount}` : `related choice ${fillerCount}`;
      fillerCount++;
      if(tryAdd(label)) continue;
      distractors.push(label);
    }

    const choices = [correct, ...distractors.slice(0,3)];
    if(choices.length<4){
      const more = distractors.slice(3).concat(closeFirst, midFirst, farFirst, semantic, gens, pool, fallbackList);
      for(const option of more){
        if(choices.length>=4) break;
        const key = normalize(option).toLowerCase();
        if(!key || key===correctKey) continue;
        if(choices.some(choice=>normalize(choice).toLowerCase()===key)) continue;
        choices.push(option);
      }
    }
    while(choices.length<4){
      const pad = promptIsHeb ? `אפשרות בונוס ${choices.length}` : `bonus option ${choices.length}`;
      choices.push(pad);
    }

    shuffle(choices);
    state.mc.choices = choices;
    state.mc.correctIndex = choices.indexOf(correct);

    const labels=['A','B','C','D'];
    [optA,optB,optC,optD].forEach((btn,i)=>{
      btn.textContent = labels[i] + ': ' + choices[i];
      btn.setAttribute('data-index', i);
      btn.classList.remove('correct','wrong');
      btn.disabled=false;
    });
  }

  // --- feedback utils ---
  function getCtx(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); return audioCtx; }
  function beep(seq){ const ctx=getCtx(); let t=ctx.currentTime; seq.forEach(([f,ms])=>{ const o=ctx.createOscillator(); const g=ctx.createGain(); o.frequency.value=f; o.type='sine'; o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t+ms/1000); g.gain.setValueAtTime(0.15,t); g.gain.exponentialRampToValueAtTime(0.001, t+ms/1000); t+=ms/1000; }); }
  function playCorrect(){ beep([[880,120],[1175,120],[1568,180]]); }
  function playWrong(){ beep([[220,160],[196,160]]); }
  function flash(ok){ const card=document.querySelector('.bigcard'); card.classList.remove('flash-green','flash-red'); void card.offsetWidth; card.classList.add(ok?'flash-green':'flash-red'); }
  function showBurst(){ let el=document.createElement('div'); el.className='burst'; el.textContent='+5 points!'; document.querySelector('.bigcard').appendChild(el); requestAnimationFrame(()=>{ el.classList.add('show'); }); setTimeout(()=>el.remove(),1000); }
  function confetti(){ const card=document.querySelector('.bigcard'); for(let i=0;i<24;i++){ const s=document.createElement('div'); s.className='confetti-piece'; s.style.left=Math.random()*100+'%'; s.style.background=`hsl(${Math.floor(Math.random()*360)},90%,60%)`; s.style.transform=`translateY(-10px) rotate(${Math.random()*360}deg)`; card.appendChild(s); setTimeout(()=>s.remove(),1000); } }

  function endRound(ok){ if(ok){ playCorrect(); showBurst(); confetti(); flash(true); setTimeout(()=>{ mark(true); }, 650); } else { playWrong(); flash(false); const ci = state.mc.correctIndex; [optA,optB,optC,optD][ci].classList.add('correct'); nextBtn.style.display='inline-block'; nextBtn.onclick=()=>{ nextBtn.style.display='none'; mark(false); } }
  }

  // --- Events ---
  const startBtnDefaultText = startBtn.textContent;

  startBtn.addEventListener('click', async ()=>{
    const deck = parseRaw(rawEl.value);
    if(deck.length===0){ alert('Please paste lines like: מילה - word'); return; }
    startBtn.disabled = true;
    try {
      let difficultyChoice = state.difficulty || 'hard';
      if(modeSel.value === 'mc4'){
        startBtn.textContent = 'Choose difficulty…';
        difficultyChoice = await requestDifficulty();
        if(!difficultyChoice) return;
      }
      state.difficulty = difficultyChoice || 'hard';
      startBtn.textContent = 'Preparing smart options…';
      await beginGame(deck);
    } finally {
      startBtn.disabled = false;
      startBtn.textContent = startBtnDefaultText;
    }
  });

  backBtn.addEventListener('click', ()=>{
    gameScreen.style.display='none'; mainScreen.style.display='block';
  });

  // Flashbar actions
  revealBtn.addEventListener('click', ()=>{
    const idx = state.queue[state.i];
    const pair = state.deck[idx];
    const answerText = state.dir==='he2en' ? pair.en.join(' / ') : pair.he;
    reveal(answerText);
  });
  correctBtn.addEventListener('click', ()=> mark(true));
  wrongBtn.addEventListener('click', ()=> mark(false));
  skipBtn.addEventListener('click', ()=>{ state.i++; remainingEl.textContent = Math.max(0, state.queue.length - state.i); showCard(); });

  // MC actions
  [optA,optB,optC,optD].forEach((btn,i)=>{
    btn.addEventListener('click', ()=>{
      if(btn.disabled) return;
      [optA,optB,optC,optD].forEach(b=>b.disabled=true);
      const ok = i===state.mc.correctIndex;
      const correctText = state.mc.choices[state.mc.correctIndex];
      if(ok){
        btn.classList.add('correct');
        answerEl.textContent = '✓ ' + correctText;
      } else {
        btn.classList.add('wrong');
        answerEl.textContent = '✗ ' + correctText;
      }
      endRound(ok);
    });
  });

  // Keys
  document.addEventListener('keydown', (e)=>{
    if(difficultyModal && difficultyModal.classList.contains('open')){
      if(e.key==='Escape'){ settleDifficulty(null); }
      return;
    }
    if(authModal.classList.contains('open')){ if(e.key==='Escape'){ hideAuthModal(); } return; }
    if(profileModal.classList.contains('open')){ if(e.key==='Escape'){ closeProfileDateMenu(); closeModal(profileModal); } return; }
    if(gameScreen.style.display!=='block') return;
    if(e.key==='Escape'){ backBtn.click(); }
    if(state.mode==='flash'){
      if(e.key===' '){ e.preventDefault(); revealBtn.click(); }
      if(e.key==='1'){ e.preventDefault(); correctBtn.click(); }
      if(e.key==='2'){ e.preventDefault(); wrongBtn.click(); }
    }
    if(state.mode==='mc4'){
      const map = { 'a':0, 'b':1, 'c':2, 'd':3, '1':0, '2':1, '3':2, '4':3 };
      const k = e.key.toLowerCase();
      if(Object.prototype.hasOwnProperty.call(map,k)){
        e.preventDefault();
        [optA,optB,optC,optD][map[k]].click();
      }
    }
    if(state.mode==='type' && e.key==='Enter'){ e.preventDefault(); /* handled on input */ }
  });
})();
</script>
</body>
</html>
